"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""


import time


def measure_time(func_for_measure):
    def func_wrapp(*args):
        time_start = time.time()
        func_result = func_for_measure(*args)
        time_end = time.time()
        print(f'Время выполнения функции {func_for_measure.__name__}: {time_end - time_start}')
        return func_result
    return func_wrapp


#a)
# Сложность: O(N)
@measure_time
def fill_list(num_of_els, a_list=[]):
    for i in range(32, 32 + num_of_els):    # O(N)
        a_list.append(chr(i))               # O(1)
    return a_list
# Время выполнения функции fill_list: 0.17998766899108887


# Сложность: O(N)
@measure_time
def fill_dict(num_of_els, a_dict={}):
    for i in range(32, 32 + num_of_els):    # O(N)
        a_dict[i] = chr(i)                  # O(1)
    return a_dict
# Время выполнения функции fill_dict: 0.21498942375183105


the_list = fill_list(1100000)
the_dict = fill_dict(1100000)


# Несмотря на то, что сложности алгоритмов заполнения списка и заполнения
# словаря одинаковые, заполнение словаря, как правило, занимает больше времени,
# чем заполнение списка, т.к. словари реализуются с помощью хеш-таблиц, а на
# хеширование ключей требуется дополнительное время.


#b)
# Сложность: O(N)
@measure_time
def get_list_el(num_of_els, a_list):
    for i in range(num_of_els):    # O(N)
        an_el = a_list[i]          # O(1)
    return an_el
# Время выполнения функции get_list_el: 0.06497073173522949


# Сложность: O(N)
@measure_time
def get_dict_el(num_of_els, a_dict):
    for i in range(32, num_of_els + 32):    # O(N)
        an_el = a_dict[i]                   # O(1)
    return an_el
# Время выполнения функции get_dict_el: 0.08499503135681152


get_list_el(1100000, the_list)
get_dict_el(1100000, the_dict)


# Получение элемента словаря выполняется дольше, чем получение элемента списка,
# за счет необходимости хеширования ключа словаря и сравнения хешей.


#с)
# Сложность: O(N^2)
@measure_time
def remove_list_el(num_of_els, a_list):
    for i in range(num_of_els):     # O(N)
        a_list.remove(chr(i + 32))  # O(N)
    return a_list
# Время выполнения функции remove_list_el: 22.0168673992157


# Сложность: O(N)
@measure_time
def del_dict_el(num_of_els, a_dict):
    for i in range(32, num_of_els + 32):    # O(N)
        del a_dict[i]                       # O(1)
    return a_dict
# Время выполнения функции del_dict_el: 0.005000114440917969


remove_list_el(15000, the_list)
del_dict_el(15000, the_dict)


# Удаление элемента словаря выполняется быстрее, чем удаление элемента списка,
# т.к. сложность соответствующего алгоритма ниже.
