"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""


import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):
    return [i for i in range(len(nums)) if nums[i] % 2 == 0]


nums_arr = [78, 9, 13, -6, 9, 0, 8]
t1 = timeit.Timer(stmt="func_1(nums_arr)", setup="from __main__ import func_1, nums_arr")
print("Время, за которое func_1  выполненяется 2000000 раз:", t1.timeit(number=2000000), "секунд.")
print("Время, за которое func_2  выполненяется 2000000 раз:",
      timeit.timeit("func_2(nums_arr)", globals=globals(), number=2000000), "секунд.")
print(timeit.repeat("func_1(nums_arr)", "from __main__ import func_1, nums_arr", timeit.default_timer, 5, 2000000))
print(timeit.repeat("func_2(nums_arr)", "from __main__ import func_2, nums_arr", timeit.default_timer, 5, 2000000))


# Код был оптимизирован: для формирования массива был использован
# list comprehension. Это немного ускортло процесс, что подтверждают
# следующие замеры, выполненные разными способами:
# Время, за которое func_1  выполненяется 2000000 раз: 3.658762499999284 секунд.
# Время, за которое func_2  выполненяется 2000000 раз: 2.678239199998643 секунд.
# 5 соответствующих замеров для func_1:
# [2.941618100001506, 3.9476249999970605, 3.7462374000024283, 2.861883700003091, 2.6873970000015106]
# Минимальное время: 2.6873970000015106 с.
# 5 соответствующих замеров для func_2:
# [2.650307399999292, 3.0887148000001616, 2.7983973000009428, 2.9378987999989477, 2.385573399998975]
# Минимальное время: 2.385573399998975 с.
