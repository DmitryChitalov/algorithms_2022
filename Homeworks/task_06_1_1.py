"""
Задание 1.

Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python

На каждый скрипт нужно два решения - исходное и оптимизированное.

Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler

Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler

Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.


ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.

Это файл для первого скрипта
"""

# Курс "Алгоритмы и структуры данных на Python."
# Задание к уроку 4:
# Определить число, которое встречается в массиве чаще всего (третья версия решения).

from memory_profiler import memory_usage


def decor(func):
    def wrapper():
        m1 = memory_usage()
        res = func()
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return res, mem_diff
    return wrapper


array = [1, 3, 1, 3, 4, 5, 1]


@decor
def func_3():
    numb_most_often, count_numb_most_often = max({el: array.count(el) for el in array}.items(),
                                                 key=lambda item: item[1])
    return f'Чаще всего встречается число {numb_most_often}, ' \
           f'оно появилось в массиве {count_numb_most_often} раз(а)'


array_tuple = tuple(array)


@decor
def func_3_v2():
    numb_most_often, count_numb_most_often = max({el: array_tuple.count(el) for el in array_tuple}.items(),
                                                 key=lambda item: item[1])
    return f'Чаще всего встречается число {numb_most_often}, ' \
           f'оно появилось в массиве {count_numb_most_often} раз(а)'


result_1, mem_diff_1 = func_3()
print(f"Выполнение заняло {mem_diff_1} Mib")
result_2, mem_diff_2 = func_3_v2()
print(f"Выполнение заняло {mem_diff_2 } Mib")

# Для оптимизации памяти было реализовано преобразование списка в кортеж.
# По результатам тестирования удалось добиться оптимизации памяти.
