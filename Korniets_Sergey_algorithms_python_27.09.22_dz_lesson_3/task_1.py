"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time

def check_time(func):
    def wrapper(*args):
        start_val = time.time()
        func(*args)
        end_val = time.time()
        return end_val - start_val
    return wrapper

new_lst = []                    # O(1)
new_dict = {}                   # O(1)

# Пункт а)
@check_time
def fill_lst(n):                # Сложность: O(n)
    for i in range(n):          # O(n)
        new_lst.append(i)       # O(1)
    return new_lst              # O(1)

@check_time
def fill_dict(n):               # Сложность: O(n)
    for i in range(n):          # O(n)
        new_dict[i] = i         # O(1)
    return new_dict             # O(1)

print('Пункт а)')
print(fill_lst(1000001))
print(fill_dict(1000001))
# Вывод: список заполняется быстрее, ввиду сложности структуры словаря

# Пункт б)
@check_time
def get_lst(n):                 # Сложность: O(n)
    for i in range(len(n)):     # O(n)
        item = new_lst[i]       # O(1)


@check_time
def get_dict(n):                # Сложность: O(n)
    for i in n.keys():          # O(n)
        item = new_dict[i]      # O(1)

print('Пункт б)')
print(get_lst(new_lst))
print(get_dict(new_dict))
# Вывод: получение элементов списка медленнее, ввиду оптимизации доступа
# к значениям словаря по ключам

# Пункт в)
@check_time
def del_lst(n):                 # Сложность: O(n^2) в худшем случае
    for i in range(len(n)):     # O(n)
        del new_lst[i]          # O(n)


@check_time
def del_dict(n):                # Сложность: O(n)
    for i in n.keys():          # O(n)
        del new_dict[i]         # O(1)

print('Пункт в)')
print(get_lst(new_lst))
print(get_dict(new_dict))
# Вывод: удаление элемента списка медленнее, так как после удаления
# каждого элемента необходимо проводить переиндексацию осташихся елементов