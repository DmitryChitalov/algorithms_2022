"""
Задание 2.
Реализуйте два алгоритма.
Оба должны обеспечивать поиск минимального значения для списка.
Сложность первого алгоритма должна быть O(n^2) - квадратичная.
Сложность второго алгоритма должна быть O(n) - линейная.

Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
-- нельзя использовать встроенные функции min() и sort()
-- каждый из двух алгоритмов нужно оформить в виде отдельной ф-ции
-- проставьте сложности каждого выражения в двух ваших алгоритмах
"""

# мне лень писать спискок, поэтому я забью случайными целыми числами список нужной длины
from random import randint

N = int(input('Введите длину списка '))
numbers = []
for i in range(N):
    numbers.append(randint(1, 99))
print(numbers)


# сложность O(N^2)
def find_min(lst):
    """
    Функция получает список и возвращает минимальное значение
        :param lst: list
            переданный список для поиска минимального значения
        :return: int
            миниальное число списка
    """
    for i in range(len(lst) - 1):
        for j in range(len(lst) - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    return lst[0]


print(find_min(numbers))


# сложность вроде O(N)
# понятное дело, что так удалятся дубли, но в рамках этой задачи неважно
# п.с. не знаю, баг это или фича, но при рандомизированном создании списка fromkeys его упорядочивает, поэтому работает

def find_min_1(lst):
    lst = dict.fromkeys(lst)  # O(N)
    return list(lst.keys())[0]  # O(1)


print(find_min_1(numbers))


# сложность O(N)
def find_min_2(lst):
    min = lst[0]
    for i in lst:  # O(N)
        if i < min:  # O(1)
            min = i  # O(1)
    return min  # O(1)


print(find_min_2(numbers))
