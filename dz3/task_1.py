"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
from random import randint
import time


def time_func(func):
    def wrapper(*args):
        start_time = time.perf_counter()
        res = func(*args)
        print(time.perf_counter() - start_time)
        return res

    return wrapper


# a)
@time_func
def lst_add():
    lst = []
    for i in range(1000):
        lst.append(randint(0, 100))      # O(1)
    return lst


print(lst_add())


@time_func
def dict_add():
    dct = {}
    for i in range(100):
        dct[i] = randint(0, 100)        # O(1)
    return dct


print(dict_add())


# В О - натации заполнение словоря это константная сложность, заполнение списка так же константная сложность.
# Замеры времени показывают что словарь заполняется быстрее


# b)
@time_func
def lst_receiving(lst, idx):
    return lst[idx]                     # O(1)


lst_2 = [2, 3, 4, 5, 6, 7, 8, 9, 0]
print(lst_receiving(lst_2, 6))


@time_func
def dct_receiving(dct, key):
    return dct[key]                    # O(1)


dct_2 = {1: 32, 2: 45, 3: 56, 4: 466, 5: 46, 6: 832, 7: 123}
print(dct_receiving(dct_2, 6))


# Получение элемента из списка константная сложность,получение значения словоря по ключу так же константная сложность,
# но замеры времени показали, что время получения элемента из словоря происходят намного быстрее

# c)
@time_func
def del_el_lst(lst, idx):
    lst.pop(idx)                    # O(n)
    return lst


lst_1 = [2, 3, 4, 5, 6, 7]
print(del_el_lst(lst_1, 4))


@time_func
def del_el_dct(dct, key):
    del dct[key]                    # O(n)
    return dct


dct_1 = {1: 4, 2: 5, 3: 6}
print(del_el_dct(dct_1, 3))


# Удаление элемента из списка это линейнаясложность, удаление из словоря, так же линейная сложность,
# замеры скорости показали, что удаление из списка происходят намного быстрее чем из словоря.