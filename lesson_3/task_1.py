"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import time

''' создаю декоратор'''

def timer_decorator (func):
    def wrapper(*args):
        time_start = time.perf_counter()
        result = func(*args)
        print(f'Время работы функции"{func.__name__}" - {time.perf_counter() - time_start}')
        return result
    return wrapper

""" a)"""

# Заполняю список 

@timer_decorator
def list_generator(n):                  # O(n)
    return [i for i in range(0, n)]     # O(n)


# Заполняю словарь
@timer_decorator
def dict_generator(n):                      # O(n)
    return {i: None for i in range(0, n)}   # O(n)


print('a)')
my_lst = list_generator(1000)
print(f'Заполнение списка: {my_lst}')
my_dct = dict_generator(1000)
print(f'Заполнение словаря: {my_dct}')

# Сложность функций одинаковая, но словарь заполняеться дольше, так как для словаря дополнительно формируется хеш-таблица.

""" b)"""
# В цикле перебираем и сравниваем каждую позицию с искомым элементом.

@timer_decorator
def list_item(lst: list, elem):     # O(n)
    for i in lst:                   # O(n)
        if i == elem:               # O(1)
            return i                # O(1)


# Сразу получаем искомый элемент.

@timer_decorator
def dict_item(dct: dict, elem):           # O(1)
    return dct[elem]                # O(1)

print('b)')
list_element = list_item(my_lst, 999)
print(f'Элемент списка: {list_element}')
dict_element = dict_item(my_dct, 999)
print(f'Элемент словаря: {dict_element}')



# Получение элемента из словаря быстрее, т.к. скорость алгоритмов измеряется в темпе роста количества операций,
# для получения элемента списка (линейное время) необходимо выполнить больше операций.
# Получение элемента словаря (константное время) происходит за одну операцию.

""" с)"""

# Удаляю элемент из списка

@timer_decorator
def del_list(lst, el):  # O(n)
    lst.remove(el)      # O(n)


# Сразу удаляем элемент из словаря
@timer_decorator
def del_dict(dct, el):  # O(1)
    del dct[el]         # O(1)


print('c)')
print(f'Удаленный элемент списка: {del_list(my_lst, 999)}')
print(f'Удаленный элемент словаря: {del_dict(my_dct, 999)}')


# Удаление элемента из словаря быстрее, т.к. количество операций у словаря меньше (константное время), соответственно и выполняется быстро.