"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для второго скрипта
"""
from memory_profiler import memory_usage
import numpy as np

'''За основу взято задание 5.4 Основы питона, "Представлен список чисел. Необходимо вывести те его элементы, 
значения которых больше предыдущего". Для решения задачи использовался метод list comprehension. Для оптимизации 
памяти кода реализована функция, получающая на выходе генератор (вторая функция с yield). Для замеров памяти 
используется декоратор, тк применить @profile из библиотеки memory_profiler не получилось. В условиях задания 
указано, что нельзя дублировать код с урока, но надеюсь это не касается декоратора для замера памяти, ведь другого 
способа я так и не нашел. Так как задание сдается одним файлом, реализация второй функции обернута в кавычки, 
запустить одновременно две функции у меня не вышло. Анализ применения генератора: произведенные замеры показали, 
что применение генератора позволило значительно сократить использование памяти, а именно: стандартное выполнение 
через список - выполнено за 1.22265625 Mib, выполнение через генератор - выполнено за 0.00390625 Mib
'''
some_list = np.random.randint(0, 300, 50000)  # код для генерации списка чисел, который будем передавать функциям,
# выполнен с помощью numpy


# в условиях задания указано, что нельзя дублировать код с урока, но надеюсь это не касается декоратора для замера
# памяти, ведь другого способа я так понимаю нет
def decor(func):
    def wrapper(*args):
        m1 = memory_usage()
        res = func(args[0])
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return res, mem_diff

    return wrapper


# 4.


@decor
def list_more_numb_1(lst):
    result = [num for i, num in enumerate(lst) if lst[i] > lst[i - 1] and i > 0]
    return result


@decor
def list_more_numb_2(lst):
    for i in range(1, len(lst)):
        if lst[i] > lst[i - 1]:
            yield lst[i]


# 1. стандартное выполнение через список - выполнено за 1.22265625 Mib
if __name__ == "__main__":
    gen, mem_differ = list_more_numb_1(some_list)
    print(f'выполнено за {mem_differ} Mib')

# 2. Выполнение через генератор!!! выполнено за 0.00390625 Mib
"""
if __name__ == "__main__":  
    res, mem_diff = list_more_numb_2(some_list)
    for i in res:
        print(i)
    print(f'выполнено за {mem_diff} Mib')
"""