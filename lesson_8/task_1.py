"""
Задание 1.
Реализуйте кодирование строки по алгоритму Хаффмана.
У вас два пути:
1) тема идет тяжело? тогда вы можете,
опираясь на примеры с урока, сделать свою версию алгоритма
Разрешается и приветствуется изменение имен переменных,
выбор других коллекций, различные изменения
и оптимизации.
2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например,
через ООП или предложить иной подход к решению.
"""
from collections import Counter
'''
Пробую реализовать вариант с элементами ООП:
1. Создаем класс Tree. Я реализовал очень простой класс, где по сути будут только ответления left и right
2. Для каждого шага реализации кодирования сделана отдельная функция.
3. Изначально мы имеем только строку, которую нужно закодировать. Строку передаем в функцию to_sort, получаем
отсортированный список с парами (символ, кол-во упоминаний в строке).
4. Полученный отсортированный список передаем в следующую функцию make_tree. Применяя класс Tree на выходе получаем 
соответствующий объект
5. Дерево Tree передаем в функцию make_hufman_code. Для обхода дерева используем способ рекурсии по примеру:
 def pre_order(node):
    if node:
        print(node.value)
        pre_order(node.left)
        pre_order(node.right)
На выходе получаем словарь таблицу ключей кода.
6. Кодируем таблицу ключей с помощью функции get_code
'''


text = 'beep boop beer!'


# создаем класс Tree
class Tree(object):

    def __init__(self, left='', right=''):
        self.left = left
        self.right = right

    def next_leaf(self):
        return self.left, self.right


# функция для сортировки строки
def to_sort(string):  # передаем строку для сортировки
    count = Counter(string)  # используем Counter для подсчета символов => Counter({'e': 4, 'b': 3, 'p': 2, ' ': 2,
    # 'o': 2, # 'r': 1, '!': 1})
    result = sorted(dict(count).items(), key=lambda x: x[1], reverse=True)  # создаем результирующий список, состоящий
    # из пар "символ - количество" result = [('e', 4), ('b', 3), ('p', 2), (' ', 2), ('o', 2), ('r', 1), ('!', 1)],
    # список переворачиваем, это будет нужно для следующей функции
    return result


# Функция формирования дерева, сделано через рекурсию
def make_tree(sort_string):  # в функцию передаем отсортированную строку (список), которую будем кодировать
    if len(sort_string) == 1:  # базовый случай для рекурсии
        return sort_string[0][0]  # функция работает пока длина sort_string > 1. Результатом будет объект класса Tree,
    # в котором будет записано наше дерево со всеми символами
    (sym_1, count_1) = sort_string[-1]  # берем первые символы с конца, т.е. минимальные
    (sym_2, count_2) = sort_string[-2]  # аналогично берем второй символ с конца, в count записываем кол-во вхождений
    sort_string = sort_string[:-2]  # срезаем эти два минимальных символа из списка
    leaf = Tree(sym_1, sym_2)  # создаем "листочек" для нашего дерева, используя класс Tree, в который скармливаем
    # наши два минимальных символа (соответственно один будет left, другой right)
    sort_string.append((leaf, count_1 + count_2))  # добавляем "листочек" в результирующий список, суммируя количество
    # вхождений
    sort_string = sorted(sort_string, key=lambda x: x[1], reverse=True)  # снова сортируем список, переворачиваем и
    # рекурсивно вызываем функцию
    return make_tree(sort_string)


# собственно сама функция для кодировки
def make_hufman_code(tree, code_number='', result={}):  # в функцию передаем наше "дерево" - объект класса Tree,
    # созданный функцией make_tree, а результат будет словарь - ключ-буква, значение - код, состоящий из нулей и единиц
    if type(tree) is not Tree:  # наше дерево состоит из звеньев (объект Tree) и листьев (буквы, символы)
        return {tree: code_number}  # если мы добираемся до символа, то записываем словарь {буква: код}
    left, right = tree.next_leaf()  # двигаемся по дереву используя функцию из класса Tree - next_leaf, возвращая
    # left и right
    result.update(make_hufman_code(left, code_number + '0', result))  # используем рекурсии, чтобы двигаться по дереву
    result.update(make_hufman_code(right, code_number + '1', result))  # и наполнять итоговый словарь-кодовую таблицу
    return result


# 1 делаем сортировку строки с помощью функции to_sort
sort_str = to_sort(text)
# 2 создаем дерево с помощью функции make_tree
tree_obj = make_tree(sort_str)
# 3 производим кодировку с помощью функции make_hufman_code
code_table = make_hufman_code(tree_obj)
print(code_table)  # => {'b': '00', ' ': '010', 'p': '011', '!': '1000', 'r': '1001', 'o': '101', 'e': '11'}
# 4. по полученному коду через цикл получаем закодированную строку
'''
for i in text:
    print(code_table[i], end=' ')  # 00 11 11 011 010 00 101 101 011 010 00 11 11 1001 1000
'''


# 4. или функцией

def get_code(code, string):
    result = ''
    for n in string:
        result += code[n] + ' '
    return result


code_string = get_code(code_table, text)
print(code_string)  # => 00 11 11 011 010 00 101 101 011 010 00 11 11 1001 1000


# функция для возврата текста по полученному коду. Для раскодировки надо иметь кодовую таблицу. В функцию передаем
# словарь-кодовую таблицу и строку, которую надо раскодировать
def get_encode(hufman_code, string, result=''):
    for x in string.split(' '):
        for sym, number in hufman_code.items():
            if x == number:
                result += sym
    return result


print(get_encode(code_table, code_string))  # => beep boop beer!
