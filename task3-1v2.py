"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

def time_measure(func):
    import time

    def wrapper(*args):  # в args (n, my_list) or (n, my_dict)
        total = 0
        if func.__name__ == 'del_list':   # для обеспечения безошибочной отработки скрипта создание списка и
# словаря осуществляется в теле декоратора(при каждой итерации создается новый список), в противном случае возможно
# получение ошибки "KeyError: 0" (т.е. использование ключа, которого нет среди ключей данного отображения)
            obj = [i for i in range(args[0])]
        elif func.__name__ == 'del_dict':
            obj = {i: i for i in range(args[0])}
        else:
            obj = args[1]
        start = time.time()
        return_value = func(args[0], obj)
        end = time.time()
        total = end-start
        print(f'Среднее время {return_value}: {total:e} секунд.')

    return wrapper


# a)
'''
Сложность в O-нотации при заполнении одного элемента объекта:
- списка O(N)
- словаря O(N)
Среднее время при заполнении объекта одним элементом (порядок):
- список:  e-8 
- словарь: e-8
Анализ: Сложность в O-нотации для списка и словаря совпадают, однако в теории сказано, что словарь - это хэш-таблица,
и при его создании происходит вычисление хэш-функции для каждого ключа, что не свойственно для списков. 
Поэтому заполнение словаря за счет дополнительной операции происходит медленнее. 
P.S. если расчитывать время отработки не для одного элемента, а для массива данных, 
то это наглядно видно и с помощью замеров. 
'''
@time_measure
def append_list(n, my_list):
    for i in range(n):
        my_list.append(i)
    return f'заполнения списка одним элементом'

@time_measure
def append_dict(n, my_dict):
    for i in range(n):
        my_dict[i] = i
    return f'заполнения словаря одним элементом'


print('---------Определение среднего времени заполнения элемента-----------')
for i in range(5, 8):
    print(f'--------------Порядок 10**{i}--------------')
    my_list = []
    my_dict = {}
    append_list(10**i, my_list)
    append_dict(10**i, my_dict)
print('---------------------------------------------------------------------')

# b)
'''
Сложность в O-нотации при получении одного элемента из объекта:
- списка O(1)
- словаря O(1)
Среднее время при заполнении объекта одним элементом (порядок):
- список:  e-8 
- словарь: e-8
Анализ: Сложность для списка и словаря совпадают, в "грокаем алгоритмы" была приведена фраза: "Хеш-функция неизменно 
связывает название с одним индексом", т.е. ключу (названию) соответствует определенный индекс (число), по которому
можно осуществить быстрый поиск. Здесь прослеживается аналогичная работа списков по получению элемента. 
Результаты замеров времени это подтверждают.
'''

@time_measure
def get_list(n, my_list):
    for i in range(n):
        my_list[i]
    return f'получения одного элемента в списке'


@time_measure
def get_dict(n, my_dict):
    for i in range(n):
        my_dict[i]
    return f'получения одного элемента в словаре'


print('---------Определение среднего времени получения элемента-----------')
for i in range(5, 8):
    print(f'--------------Порядок 10**{i}--------------')
    my_list_2 = [j for j in range(10**i)]
    get_list(10**i, my_list_2)
    my_dict_2 = {j: j for j in range(10**i)}
    get_dict(10**i, my_dict_2)
print('---------------------------------------------------------------------')

# c)
'''
Сложность в O-нотации при удалении одного элемента из объекта:
- списка O(N)
- словаря O(1)
Среднее время при заполнении объекта одним элементом (порядок):
- список:  e-8 
- словарь: e-8
Анализ: в теории время операции удалени элемента для списка должно быть больше, чем для словаря, 
что и подтверждается при многократном запуске замеров времени -
для списка данная операция в среднем отрабатывает чуть медленнее.
'''


@time_measure
def del_list(n, my_list):
    for i in range(n):
        del my_list[0]  #  удаление элемента с индексом 0
    return f'удаления одного элемента в списке'


@time_measure
def del_dict(n, my_dict):
    for i in range(n):
        del my_dict[i]  #  удаление элемента по ключу
    return f'удаления одного элемента в словаре'


print('---------Определение среднего времени удаления элемента-----------')
for i in range(5, 8):
    print(f'--------------Порядок 10**{i}--------------')
    my_list_3 = []
    my_dict_3 = {}
    append_list(10**i, my_list_3)
    append_dict(10**i, my_dict_3)
print('---------------------------------------------------------------------')
