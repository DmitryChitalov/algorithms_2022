"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""

##############################################################################
"""
Вариант 1 - использование стандартной конструкции цикла for
Вариант 2 - использование вложенного списка с уловием

Скорость работы: на одинаковых наборах данных Вариант 2 в среднем на 30%
быстрее, чем Вариант 1.

Предположительная причина: вложенный список при формировании итогового массива
несколько иначе работает с памятью, т.к. при отборе очередного значения
возвращает результат итерации и формирует итоговый массив, как единую структуру,
в то время как алгоритм Варианта 1 использует явное задание итогового массива,
выделение под него памяти, поиск свободной ячейки при добавлении очередного
элемента методов append).
"""

from timeit import timeit

# Вариант 1 (стандарнтый цикл for)
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr

# Вариант 2 (вложенный список)
def func_2(nums):
    return [x for x in nums if x % 2 == 0]

# Тестирование
print('  func_1\t  func_2\t На 10 000 запусках для списка из:')
for n in (10, 100, 1000):
    nums = list(range(1,n))
    res1 = timeit("func_1(nums)", globals=globals(), number=10_000)
    res2 = timeit("func_2(nums)", globals=globals(), number=10_000)
    print(f'{res1:>8.5f}\t', end='')
    print(f'{res2:>8.5f}\t - {n} элементнов func_2 быстрее func_1 на {(1-res2/res1)*100:.0f}%')