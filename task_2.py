"""
Задание 2.

Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.

Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.

Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""

##############################################################################
"""
На примере задачи с реверсом числа на основе рекурсии.

--> Описание проблемы:
Gроблема заключается в том, что на каждом шаге рекурсии декоратор возвращает 
2 значения - результат работы рекурсивной функции и размер исполльзуемой памяти,
поэтому при попытке рекурсивной функции на очередном шаге воспользоваться
результатом работы от вложенного вызова возникает ошибка, т.к. для дальнейшей
работы необходимо только первое возвращаемое значение.

--> Решение проблемы:
Чтобы решить проблему, необходимо сделать так, чтобы декоратор возвращал 2 значения
только для самого первого вызова рекурсивной функции, а для всех остальных
вложенных шагов рекурсии необходимо возвращать только 1 значение - результат
работы рекурсии. Для того, чтобы отличить "вложенные" декораторы от "исходного",
используется сравнение между перемнной n, содержащей первоначальное значение
аргумента для первого вызова рекурсивной функции, и переменной args[0], в которой
лежит значение аргумента для текущего шага рекурсии (для "вложенных" декораторов
переменная n является внешней/глобальной, поэтому ее значение не меняется от 
шага к шагу). 

"""

from memory_profiler import memory_usage

def decor(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        # --- для отслеживания: начало
        tab = '\t' * (len(str(n)) - len(str(args[0])))
        tab += '\t' if args[0] == 0 else ''
        print(f'{tab}wrapper begin: n={n}, cur_n={args[0]}')
        # --- для отслеживания: конец
        res = func(args[0])
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        # --- для отслеживания: начало
        print(f'{tab}wrapper end: n={n}, res={res}, mem={mem_diff} Mib')
        # --- для отслеживания: конец
        # вместо возвращение 2-х результатов:

        # return res, mem_diff

        # используется возвращение 2-х результатов только для самого первого
        # декоратора, для вложенных декораторов возвращается только резульат
        # работы рекурсии:

        if args[0] == n:
            return res, mem_diff
        else:
            return res

    return wrapper

@decor
def revers(n):
    return '' if n == 0 else str(n % 10) + revers(n // 10)

n = 123
print('---> Промежуточное отслеживание')
res, mem_diff = revers(n)
print('----------------------------------')
print(f'Выполнение заняло {mem_diff} Mib')
print('----------------------------------')
