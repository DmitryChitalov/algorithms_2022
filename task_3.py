"""
Задание 3.

Для этой задачи
1) придумайте 2-3 решения (обязательно с различной сложностью)
2) оцените сложность каждого выражения в этих решениях в нотации О-большое
3) оцените итоговую сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
"""

import random
import string


##############################################################################
def top_1(lst):
    """Функция возвращает список из наименований 3-х компаний с наибольшей
    годовой прибылью в порядке убывания (с указанием размера их годовой
    прибыли).
    Алгоритм 1:
    Проходимся по списку несколько раз и путем попарных сравнений годовый
    прибылей сортируем значения в списке по возрастанию (пузырьковая
    сортировка). Возвращаем последние 3 элемента списка.
    Сложность: O(n^2)
    """
    n = len(lst)                                        # О(1)
    for i in range(n - 1):                              # О(n)
        for j in range(n - i - 1):                      # О(n)
            if lst[j][1] > lst[j+1][1]:                 # O(1)
                lst[j], lst[j+1] = lst[j+1], lst[j]     # O(1)
    return [lst[n-1], lst[n-2], lst[n-3]]               # O(1)

##############################################################################
def top_2(lst):
    """Функция возвращает список из наименований 3-х компаний с наибольшей
    годовой прибылью в порядке убывания (с указанием размера их годовой
    прибыли).
    Алгоритм 2:
    В дополнительный список сохраняются первые 3 элемента исходного списка.
    Проходимся по списку и сравниваем минимальное значение из дополнительного
    списка со значением каждого из оставшихся элементов в исходном списке:
    если годовая прибыль очередного элемента исходного списка больше годовой
    прибыли минимального элемента из дополнительного списка, то заменяем
    минимальный элемент дополнительного списка на данный элемент исходного
    списка, иначе - ничего не делаем.
    После прохождения всего списка в дополнительном списке останутся ТОП-3
    компании с наибольшей годовой прибылью.
    Сложность: O(n)
    """
    top = sorted(lst[0:3], key=lambda x: x[1], reverse=True)            # O(1)
    for i in range(4, len(lst)):                                        # O(n)
        if lst[i][1] > top[2][1]:                                       # O(1)
            top[2] = lst[i]                                             # O(1)
            top = sorted(top[0:3], key=lambda x: x[1], reverse=True)    # O(1)
    return top                                                          # O(1)

##############################################################################
def top_3(lst_obj):
    """Функция возвращает список из наименований 3-х компаний с наибольшей
    годовой прибылью в порядке убывания (с указанием размера их годовой
    прибыли).
    Алгоритм 3:
    Исходный массив сортируется по убыванию с помощью стандартной функции
    sort с указанием ключа сортировки. Возвращаем первые 3 элемента списка.
    Сложность: O(n*log_n)
    """
    lst_sort = sorted(lst, key=lambda x: x[1], reverse=True)    # O(n*log_n)
    return lst_sort[0:3]                                        # O(1)

##############################################################################
"""
Вывод: эффективнее всего алгоритм 2, т.к. он имеет временную сложность О(n),
которая меньше, чем O(n*log_n) или O(n^2).

Замечание: 1-ый алгоритм не всегда будет возвращать такой же набор из 3-х
компаний, как и алгоритмы 2 и 3,и порядок их расположения в 1-ом алгоритме
может отличаться от порядка во 2 и 3 алгоритмах, т.к. сортировка проводится
лишь по размеру годовой прибыли без дополнительной сортировки наименований
компаний (например, в алфавитном порядке) в случае одинакового размера
годовой прибыли.
"""


##############################################################################
"""Тестирование"""

# Генерация случайного слова
def generate_random_string(length):
    letters = string.ascii_lowercase
    word = ''.join(random.choice(letters) for i in range(length))
    return word.capitalize()

# Генерация тестового массива
lst = []
for i in range(10):
    lst.append((generate_random_string(random.randint(7, 10)), random.randint(5, 150)))

print(lst)
print(*top_1(lst))
print(*top_2(lst))
print(*top_3(lst))