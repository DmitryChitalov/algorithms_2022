"""
Задание 3.

Для этой задачи
1) придумайте 2-3 решения (обязательно с различной сложностью)
2) оцените сложность каждого выражения в этих решениях в нотации О-большое
3) оцените итоговую сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
"""
# в словаре ключ - это название компании, а значение - прибыль
# Итоговая сложность O(n)
def search_On(dict):
    company = {}    #O(1)
    company.update(dict)    #O(n)
    list_rez = [company.popitem(), company.popitem(), company.popitem()]    #O(1)
    for i in range(3):  #O(1)
        for item in company.items(): #O(n)
            if item[1] > list_rez[i][1]:    #O(1)
                list_rez[i] = item  #O(1)
        if list_rez[i][0] in company:   #O(1)
            del company[list_rez[i][0]]     #O(1)
    return list_rez #O(1)

# Итоговая сложность O(n*log*n)
def search_nlogn(dict):
    list_rez = list(dict.items()) #O(n)
    list_rez.sort(key=lambda el: el[1], reverse=True)   #O(n*log*n)
    return list_rez[:3] #О(1)

if __name__ == '__main__':
    database = {'ООО Зощенко': 1000, 'ООО Бажов': 1000, 'ООО Носов': 5000, 'ООО Андер': 3000, 'ООО Катаев': 2000, 'ООО Гуркин': 7000}
    print(search_On(database))
    print(search_nlogn(database))
# В решении O(n) простой поиск время выполнения алгоритма прямо пропорционально размеру входящих данных.
# Чем больше элементов в массиве, тем больше и время выполнения алгоритма.
# Время выполнения алгоритма прямо пропорционально размеру входящих данных.

#В решении O(n*log*n) быстрая сортировка массив разбивается на подмассивы до тех пор, пока в каждом не будет по два элемента.
# Каждая пара сортируется, а далее отсортированные пары объединяются.
# Продолжается сортировка полученного результата.
#Первое решение оптимальнее O(n), т.к. линейная зависимость количества элементов от операций.
