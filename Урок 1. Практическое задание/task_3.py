"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (обязательно с различной сложностью)
2) оцените сложность каждого выражения в этих решениях
3) оцените итоговую сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание: ПРОШУ ВАС ВНИМАТЕЛЬНО ЧИТАТЬ ЗАДАНИЕ!
"""
####################################################

dic = {'Amazon': 100, 'Apple': 200, 'Microsoft': 300, 'Visa': 400, 'Alibaba': 500}

def check_1(dic):
    """
    Сложность: O(n)
    """

    lst_max = {}                                                                    # O(1)
    while len(lst_max) < 3:                                                         # O(1)
        max_v = 0                                                                   # O(1)
        for k, v in dic.items():                                                    # O(n)
            if max_v < v:                                                           # O(1)
                key_max = k                                                         # O(1)
        max_value = dic.pop(key_max)                                                # O(1)
        lst_max.setdefault(key_max, max_value)                                      # O(1)

    return lst_max                                                                  # O(1)

# print(check_1(dic))

####################################################

def value(item):
    return item[1]                                                              # O(1)

def check_2(dic):
    """
    Сложность: O(n log n)
    """
    lst_max = dict()                                                            # O(1)
    i = 0                                                                       # O(1)
    for k, v in sorted(dic.items(), key=value, reverse=True):                   # O(n + n log n)
        if i < 3:                                                               # O(1)
            lst_max.setdefault(k, v)                                            # O(1)
        i = i + 1                                                               # O(1)
    return lst_max                                                              # O(1)

print(check_2(dic))

# Вывод: Check_2, будет выполнятся быстрее т.к у него сложность sorted() - Линейно-логарифмическая,
# а у первого Квадратичная то есть время выполнения дольше

