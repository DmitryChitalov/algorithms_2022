"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
from time import time

LIST = []
DICT = {}


def timer(func):
    def wrapper(*args, **kwargs):
        start = time()
        func(*args, **kwargs)
        print(func.__doc__, f'Затраченное время: {time() - start}')
    return wrapper


@timer
def fill_in_list(lst):
    """Заполнение списка элементами (сто тысяч элементов)."""
    for i in range(100_000):    # O(n)
        lst.append(i)           # O(1) ==> Общая O(n)


@timer
def fill_in_dict(dct):
    """Заполнение словаря элементами (сто тысяч пар ключ: значение)."""
    for i in range(100_000):    # O(n)
        dct[i] = i              # O(1) ==> Общая O(n)


fill_in_list(LIST)
fill_in_dict(DICT)
"""
Список заполняется быстрее, так как содержит только значения. Словари содержат и ключ и значение для этого ключа,
поэтому и заполнение его происходит дольше при одинаковой сложности функций.
"""

print('=' * 100)


@timer
def get_elem_list(lst):
    """Получение элементов из списка."""
    for i in range(len(lst)):   # O(n)
        x = lst[i]              # O(1) ==> Общая O(n)


@timer
def get_elem_dict(dct):
    """Получение элементов из словаря."""
    for i in range(len(dct)):   # O(n)
        x = dct[i]              # O(1) ==> Общая O(n)


get_elem_list(LIST)
get_elem_dict(DICT)
"""
Получение элементов из списка в данном примере зависит от примененного метода и достигает квадратичной сложности.
В словаре(хеш-таблице) искомое значение можно получить без полного перебора элементов (ключ ==> хеш ключа ==> значение).
"""


print('=' * 100)


@timer
def del_elem_list(lst):
    """Удаление элементов из списка."""
    for i in range(len(lst)):  # O(n)
        # del lst[0]             # O(n) ==> Общая O(n^2)
        lst.pop()            # O(1) ==> Общая O(n)
        # lst.pop(0)           # O(n) ==> Общая O(n^2)


@timer
def del_elem_dict(dct):
    """Удаление элементов из словаря."""
    for i in range(len(dct)):  # O(n)
        # del dct[i]             # O(1) ==> Общая O(n)
        dct.pop(i)           # O(1) ==> Общая O(n)
        # dct.popitem()        # O(1) ==> Общая O(n)


del_elem_list(LIST)
del_elem_dict(DICT)
"""
Удаление элементов из списка также зависит от примененного метода. 
Удаление элементов из словаря имеет постоянную сложность при применении любых методов, и в этом примере имеет линейную
сложность
"""
