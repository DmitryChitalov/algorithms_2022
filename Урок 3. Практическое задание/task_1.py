"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import functools
import time


def func_time(func):
    """Выводит время выполнения декорируемой функции"""

    @functools.wraps(func)
    def wrapper_func_time(*args, **kwargs):
        start_time = time.perf_counter()
        value = func(*args, **kwargs)
        end_time = time.perf_counter()
        run_time = end_time - start_time
        print(f"Функция {func.__name__} выполнена за {run_time:.6f} с")
        return value

    return wrapper_func_time


my_list = range(1, 10000)


# O(n)
@func_time
def add_to_list(my_list):
    return [el for el in my_list]  # O(1)+O(n)+O(n)


# O(n)
@func_time
def add_to_dict(my_list):
    return {i: i for i in my_list}  # O(1)+O(n)+O(n)


'''результаты измерение времени выполнения функции зависит от количества исходных данных при создании списка или словаря 
 из 10-1000 элементов результат не показателен но при увиличении количества элементов до 10 000 и больше словарь 
 начинает значительно проигрывать (в среднем в два раза) по скорости создания, как мне кажется причина этому хеширование 
 данных и создание пары '''


# O(n)
@func_time
def get_list_el(my_list, el):
    for i in my_list:  # O(n)
        if i == el:  # O(1)
            return i  # O(1)


# O(n)
@func_time
def get_dict_el(my_dict, el):
    for i in my_dict:  # O(n)
        if i == el:  # O(1)
            return my_dict[el]  # O(1)+O(n)


'''при замерении времени работы функций никакой разници я не увидел хотя словарь как по мне должен отрабатывать быстрее 
его для этого по сути и придумали'''


# O(n)
@func_time
def del_list_el(my_list, el):
    for i in my_list:  # O(n)
        if i == el:  # O(1)
            return my_list.remove(i)  # O(1)+O(n)


# O(n)
@func_time
def del_dict_el(my_dict, el):
    for i in my_dict:  # O(n)
        if i == el:  # O(1)
            return my_dict.pop(el)  # O(1)+#O(1)


'''при замерении времени работы функций список существенно проигрывает по скорости так как при удалении элемента он 
ищется по всему списку а в словаре он определяется по ключу'''

my_list2 = add_to_list(my_list)
my_dict2 = add_to_dict(my_list)
print(get_list_el(my_list2, 4))
print(get_dict_el(my_dict2, 4))
del_list_el(my_list2, 4)
print(del_dict_el(my_dict2, 4))
