"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import time


def check_time(in_func):
    """Функция для расчета времени выполнения передаваемых в нее функций
    На вход функция получает наименование функции, замеряет время начала и завершения функции и
    передает аргументы в исполняемую функцию и возвращает время исполнения"""
    def time_counter(*args, **kwargs):
        start = time.perf_counter()  # Считаем доли секунды
        result = in_func(*args, **kwargs)
        end_time = time.perf_counter()  # Считаем доли секунды
        print(f'Время работы функции {in_func.__name__} составило {end_time-start:.6f} секунд')
        return result
    return time_counter


"""Реализация первого задания"""


@check_time
def filling_list(end_num: int):
    """Функция принимает в себя число и создает вложенный список строковых и числовых значений от 0 до введенного числа
    и возвращает полученный список.
    СЛОЖНОСТЬ: O(N)
    PS: Использую именно вложенный список, чтобы иметь похожую структуру данных со словарем"""
    out_list = [[str(x), x] for x in range(end_num)]
    return out_list


@check_time
def filling_dict(end_num: int):
    """Функция принимает в себя число и создает словарь строковых и числовых значений значений от 1 до введенного числа
    и возвращает полученный словарь.
    СЛОЖНОСТЬ: O(N) - O(len(N))
    """
    out_dict = dict((str(x), x) for x in range(end_num))
    return out_dict


print('Реализация первого задания')
task1_list = filling_list(1000000)
task1_dict = filling_dict(1000000)
print()

"""
По классике при добавлении значений в список не проивзодится практически никаких преобразований.
Новое значение преобразуется в байты и добавляется к существующему списку.
А перед добалением в словарь как минимум проверяется уникальность ключа и хешируются данные
В моем случае это не так очевидно, потому что список заполняется вложенными значениями
Впрочем если бы мной вносились изменения в уже сформированный список через insert то существенные ресурсы
были бы потрачены на перестроение списка
"""

"""Реализация второго задания"""


@check_time
def get_list_elem(list_n: list, index: int):
    """Функция принимает в себя список и индекс значения, которое мы ищем
    и возвращает значение списка
    СЛОЖНОСТЬ: O(1) поиск по индексу"""
    return list_n[index]


@check_time
def get_dict_elem(dict_n: dict, key: int):
    """Функция принимает в себя словарь и ключ значения, которое мы ищем
    и возвращает значение словаря
    СЛОЖНОСТЬ: O(1) поиск по ключу"""
    return dict_n[key]


print('Реализация второго задания')
get_list_elem(task1_list, 50000)
get_dict_elem(task1_dict, '50000')
print()

"""Получение элемента списка по индексу не существенно медленнее получения значеня по ключу"""


@check_time
def del_list_elem(list_n: list, pattern):
    """Функция принимает в себя список и значения, для удаления
    и удаляет значение из списка
    СЛОЖНОСТЬ: O(N)"""
    list_n.remove(pattern)


@check_time
def del_dict_elem(dict_n: list, pattern):
    """Функция принимает в себя словарь и ключ, для удаления
    и удаляет значение из словаря
    СЛОЖНОСТЬ: O(1)"""
    dict_n.pop(pattern)


print('Реализация третьего задания')
del_list_elem(task1_list, ['50000', 50000])
del_dict_elem(task1_dict, '50000')
print()

"""Удаление элемента в списке требует существенно больше ресурсов,
 чем удаление занчения словаря по ключу, так же как и при вставлении значений
 существенные ресурсы тратятся на перестроение списка
"""
