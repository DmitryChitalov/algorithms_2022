"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


def times(func):
    def wrapper(*args, **kargs):
        start = time.perf_counter()
        res = func(*args, **kargs)
        end = time.perf_counter()
        print(f'Функция выполнилась за {end - start}')

    return wrapper


@times
def to_fill_list_1(items, count):
    """Сложность функции O(n)"""
    for i in range(count):  # Сложность O(n)
        # Сложность O(1), так как мы вставляем в конец списка
        items.append(i)


@times
def to_fill_list_2(items, count):
    """Сложность функции O(n^2)"""
    for i in range(count):  # Сложность O(n)
        # так как мы вставляем в начало списка,
        # и другие элементы сдвигаются на один вправо и
        # следоватьльно сложность становиться становиться O(n)
        items.insert(0, i)


@times
def to_fill_dict(items, count):
    """Сложность функции O(n)"""
    for i in range(count):  # Сложность O(n)
        # Так как у нас добавление в словарь сложность O(1),
        # а нам нужно добавить n элементов то сложность сразу становиться O(n)
        items[i] = i


items_lst = []  # Список для заполнения
items_dict = {}  # Словарь для заполнения
count = int(input('Введите количесво итераций для заполнения: '))

# Задание a)
print('Создание')
to_fill_list_1(items_lst, count)
to_fill_list_2(items_lst, count)
to_fill_dict(items_dict, count)
print('__' * 10)


# Создание
# Функция выполнилась за 0.009786399999939022
# Функция выполнилась за 12.775586571999156
# Функция выполнилась за 0.018759241000225302

"""
Можно сделать вывод, что элементы добавляться в конец списка будут быстрее
чем в словарь, так он при добавлении высчитывает хеш.
"""


# Задание b)

@times
def to_get_item_list(items):
    """Сложность функции O(n)"""
    for i in range(len(items)):  # Сложность O(n)
        items[i] = 'update'  # изменение элемента из списка по индексу имеет O(1)


@times
def to_get_item_dict(items):
    """Сложность функции O(n)"""
    for i in items.keys():  # Сложность O(n)
        items[i] = 'update'  # изменение элемента из словаря имеет O(1)


print('Изменение')
to_get_item_list(items_lst)
to_get_item_dict(items_dict)

print('__' * 10)
# Изменение
# Функция выполнилась за 0.023149778999140835
# Функция выполнилась за 0.010127202000148827
"""
операции изменения по ключу так же работают быстрее у словарей чем у списков.
словарь - хеш-таблица, и он знает где лежит каждая запись по ключу.
"""


# Задание c)

@times
def to_remove_item_list(items):
    """Сложность функции O(n)"""
    for i in range(len(items)):  # O(n)
        items.pop()  # Сложность O(1) так как мы тут удаляем с конца.


@times
def to_remove_item_dict(items):
    """Сложность функции O(n)"""
    for k in list(items):  # O(n)
        items.pop(k)  # Сложность O(1) так как мы тут удаляем по ключу.


print('Удаление')
to_remove_item_list(items_lst)
to_remove_item_dict(items_dict)


# Удаление
# Функция выполнилась за 0.018189016000178526
# Функция выполнилась за 0.00797296300053131

"""
При удалении O(1) словарь работает так как словарь у нас хеш-таблица
"""
