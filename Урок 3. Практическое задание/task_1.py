"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
from time import time

n = 10 ** 6


def time_decorator(func):
    def time_test(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        end = time()
        print(f'время выполнения функции {func.__name__} {end - start}')
        return result

    return time_test


@time_decorator
def list_append(lst, n):
    for i in range(n):
        lst.append(i)  # O(1) Вставка в конец


new_lst = []
list_append(new_lst, n)
print('_' * 50)


@time_decorator
def dict_app(some_dict, n):
    for i in range(n):
        some_dict[i] = i  # так как словарь это хеш-таблица,
        # оперция заполнения словаря занимает меньше времени


some_dict = dict()
dict_app(some_dict, n)
print('_' * 50)


# Операции удаления, получения по индексу и ключу

@time_decorator
def del_and_change_lst(some_lst):
    for i in range(1000):
        some_lst.pop(i)
    for j in range(1000):
        some_lst[j] = some_lst[j - 1]


del_and_change_lst(new_lst)
print('_' * 50)

"""
В функции del_and_change_lst операции удаления элемента не 
с конца списка lst.pop(i) выполняются за О(n). Обращение по
индексу с изменением элемента списка выполняется за О(1).
"""


@time_decorator
def del_and_change_dict(some_dict):
    for i in range(1000):
        some_dict.pop(i)
    for j in range(1000):
        some_dict[j] = 'fill'


del_and_change_dict(some_dict)
print('_' * 50)
"""
В функции change_dict(some_dict) все операции 
изменения словаря проходят за время O(1).
Следовательно функция по изменению словаря отрабатывает гораздо быстрее.
"""
