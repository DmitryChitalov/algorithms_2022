"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time
from random import randint


# from random import randrange, sample


# Декоратор - вычисление времени
def calc_time(func):                    # O(1)
    def wrapper(*args, **kwargs):
        start = time.time()
        res = func(*args, **kwargs)
        end = time.time()
        print('Время выполнения функции {}: {} секунд.'.format(func.__name__, end - start))
        return res

    return wrapper


#################################################################################################################
# # a) Заполнение списка / словаря

# Список
@calc_time
def add_in_list(lst_1, lst_2):      # O(n)
    for el_2 in lst_2:              # O(n)
        lst_1.append(el_2)          # O(1)
    return lst_1


@calc_time
def ins_in_list(lst_1, lst_2):      # O(n)
    for el_2 in lst_2:              # O(n)
        lst_1.insert(0, el_2)          # O(n)
    # return lst_1


@calc_time
def add_in_dict(dict_1, dict_2):  # O(2*n)   -- порядок сложности O(n)
    for key_2, val_2 in dict_2.items():         # O(2*n)
        dict_1[key_2] = val_2                   # O(1)
    return dict_1


lst_1 = [randint(5, 10) for i in range(0, 200)]
lst_2 = [randint(5, 10) for i in range(0, 200000)]



dict_1 = {i: i ** 2 for i in range(0, 200)}
dict_2 = {i: i ** 2 + 50 for i in range(0, 200000)}

lst_new = add_in_list(lst_1, lst_2)
dict_new = add_in_dict(dict_1, dict_2)
print(ins_in_list(lst_1, lst_2))

print(len(lst_new))
print(len(dict_new))
# аналоги
# lst_1.extend(lst_2)
# dict_1.update(dict_2)



# по замерам времени - заполнение списка (append) выполняется быстрее словаря (одинаковая сложность O(1))
# словарь - хэш таблица и операция добавления имеет сложность O(1)
# метод списка  insert() - медленее, т.к. сложность O(n)


# ################################################################################################################
# # b) Получение элемента из списка / словаря

#########################
# Список
@calc_time
def get_el_lst(lst, n):                # O(n)
    lst_new = []
    for i in range(n):                  # O(n)
        el = lst[i]                     # O(1)

##########################
# Словарь
@calc_time
def get_el_dict(dict, n):          # O(n)
    i = 0
    for key in dict.keys():         # O(n)
        if i <= n:                  # O(1)
            el = dict[key]           #O(1)
            i += 1                  # O(1)


get_el_lst(lst_1, 5)
get_el_dict(dict_1, 5)

# правильный ответ: для словаря - быстрее, т.к. сложность операции изменения элемента - O (1)

# ??
# почему для словаря быстрее должно быть ? для списка el = lst[i] - тоже сложность O(1)
# ??? Сложность алгоритмов - одинаковая O(n), при увеличении объёма данных - рост времени будет линейный
# по замерам времени - заполнение списка выполняется быстрее словаря


# ###############################################################################################################
# # c) Удаление элемента из списка / словаря

@calc_time
def pop_lst(lst, n):            #O(n)
    for i in range(n):          # O(n)
        lst.pop()               #O(1)
    return lst

@calc_time
def pop_dict(d, n):         # O(n)
    i = 0
    dict_copy = dict(d)         # O(n)

    for key in d.keys():        # O(n)
        if i <= n:              # O(1)
            dict_copy.pop(key)  # O(1)


pop_lst(lst_2, 10)
pop_dict(dict_2, 10)

# то же как в пункте b)
