"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

"""
    Декоратор, выводящий время, которое заняло
    выполнение декорируемой функции.
"""

import time
from random import randint


def benchmark(func):
    def wrapper(*args, **kwargs):
        t = time.time()
        res = func(*args, **kwargs)
        print(func.__name__, time.time() - t)
        return res

    return wrapper


# a)

@benchmark
def list_completion(amount):
    lst = ['test text' for _ in range(amount)]  # O(N)
    return lst


@benchmark
def dictionary_completion(amount):
    dict = {i: 'test text' for i in range(amount)}  # O(N)
    return dict


"""
Вывод:  сложность в O-нотации для заполнения списка и словаря одинаковая O(N), но по замерам времени добавления
100000 элементов мы видим, что для списка это порядка 0.002 сек., а для словаря 0.007 тоесть в 3 раза дольше.
Добавление в список и в словарь одного элемента имеет одинаковую сложность О(1), но разную длительность во времени.
Поэтому нельзя судить о быстродействии только по сложности.
Словарь заполняется дольше,т.к. необходимо время для расчета хэш функций.
"""


# b)

@benchmark
def list_get_el(lst):
    for _ in range(len(lst)):  # O(N)
        i = randint(0, 99999)  # O(1)
        el = lst[i]  # O(1)


@benchmark
def dict_get_el(dict):
    for _ in range(len(dict)):  # O(N)
        i = randint(0, 99999)  # O(1)
        el = dict.get(i)  # O(1)


"""
Вывод:  сложность в O-нотации для получения  произвольного элемента списка и словаря одинаковая O(1), но по замерам 
времени извлечения 100000 элементов мы видим, что для списка это порядка 0.06 сек., 
а для словаря 0.007 тоесть в 1,2 раза дольше. Извлечение из списока и  словаря одного элемента имеет одинаковую 
сложность О(1), но разную длительность во времени.
Извлечение из списка 100000 элементов происходит быстрее чем из словаря
"""


# c)

@benchmark
def list_del_el(lst):
    len_lst = len(lst)
    for i in range(len_lst):  # O(N)
        del lst[len_lst - i - 1] #O(N)


@benchmark
def dict_del_el(dict):
    for i in range(len(dict)):  # O(N)
        del dict[i]  # O(1)

"""
Вывод:  сложность в O-нотации для удвления  произвольного элемента списка O(N) a словаря  O(1), и по замерам 
времени удаления 100000 элементов мы видим, что для списка это порядка 0.007 сек., 
а для словаря 0.005 тоесть в 1,2 раза быстрее. Удаление из списока и  словаря одного элемента имеет разную сложность 
(O(N) и О(1))но несмотря на это реальная разница на 100000 элементов не так уж и велика
Удаление из списка 100000 элементов происходит немного медленнее чем из словаря, что коррелируется со сложностью

В целом выбирая по критерию быстродействия между словарем и списком надо определится каких операций будет больше
"""

if __name__ == '__main__':
    amount = 100000
    # a)
    print('a)')
    lst = list_completion(amount)  # 0.002
    dict = dictionary_completion(amount)  # 0.07

    # b)
    print('b)')
    list_get_el(lst)  # 0.06
    dict_get_el(dict)  # 0.07
    # c)
    print('c)')
    list_del_el(lst) #0.007
    dict_del_el(dict) #0.005
