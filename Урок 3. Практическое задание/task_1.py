"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

from time import perf_counter_ns


def timer(func):
    """
    Небольшой декоратор для замеров времени работы функции. Используем версию с наносекундами, что бы наблюдать
    комфортные для восприятия цифры, а не вида 0.00000000000000е-1 и т.п.
    """

    def wrapper(*args, **kwargs):
        start = perf_counter_ns()
        res = func(*args, **kwargs)
        print(f'Функция {func.__name__} выполнена за {perf_counter_ns() - start} наносекунд')
        return res

    return wrapper


# Часть а:
@timer
def list_input(n):
    """
    В функции заполнения списков используем генератор списков. Значение n которое принимает функция -
    количество элементов списка Итоговая сложность функции O(n).
    """
    my_list = [n + 1 for n in range(n)]
    return my_list


@timer
def dict_input(n):
    """
    В функции заполнения словарей используем генератор словарей. Значение n которое принимает функция -
    количество элементов списка Итоговая сложность функции O(n).
    """
    my_dict = {n + 1: n + 1 for n in range(n)}
    return my_dict


# Часть b:

@timer
def get_list_el(user_list, n):
    """
    Функция принимает список, номер элемента списка, и возвращает значение элемента
    """
    return user_list[n]


@timer
def get_dict_el(user_dict, n):
    """
    Функция принимает словарь, ключ, и возвращает значение ключа Итоговая сложность функции O(1)
    """
    return user_dict[n]


# Часть с:

@timer
def del_list_el(user_list, n):
    """
    Функуия принимает список и номер элемента для удаления, и возвращает список без удаляемого элемента
    Итоговая сложность функции O(n)
    """
    return user_list.copy()


@timer
def del_dict_el(user_dict, n):
    """
    Функция принимает словарь и ключ, удаляет элемент по ключу, и возвращает словарь без удаляемого элемента
    Итоговая сложность функции O(n)
    """
    return user_dict.pop(n)


"""
Запускаем на исполнение следующие команды (я запускал раз ~ 10, результаты замера таймера в комментах):
"""

a = list_input(1000)  # 1600 - 2300 нс
b = dict_input(1000)  # 2900 - 6000 нс
# В целом генерация словаря идет по замерам ощутимо быстрее где то на 1000 - 2000 нс
get_list_el(a, 3)  # 300 - 800
get_dict_el(b, 3)  # 300 - 600
# В этих замерах функции очень часто показывалиодинаковые результаты. но в половине случаев
# получение элемента из словаря было быстрее на 100 нс
del_list_el(a, 3)  # 1200 - 2600
del_dict_el(b, 3)  # 1100 - 2200
# И тут словарь занимает лидирующие позиции в среднем опережая по скорости на 100 - 500 нс список!
# При одинаково сложности функций согласно O-нотации, делаем однозначный вывод: Словари - скорость!
# И все благодаря хешам)
"""
P.S.  поменял местами вызовы функций, и все координально поменялось! Генерация списка стала быстрее чем генерация 
словаря в среднем в 2 раза. Удаляться из списка стало на 400 - 600 нс быстрее... 
И тут я чесно говроря в замешательстве, какой вывод сделать...
Хотя, нет, знаю. 
В первый раз я гернерировал списски и словари с 5 элементами, усложняем до тысячи. Генерация списка стабольно быстрее в 
2 раза чем генерация словаря, как ни меняй местами порядок выполнения команд. (создание списка за ~ 60000 - 90000 нс, 
словаря - 100000 - 170000 нс)
Так же, наверное не очень правильный подход был у меня и при оценке скорости операции удаления. Модифицируем обе 
функции на "Чистое" удаление. Передаем в функцию список/словарь и номер удаляемого элемента. И только удаляем этот 
элемент. И вот тут, особенно на списке/словаре из 1000 элементов функция словаря работает в среднем в 4 раза быстрее 
функции списка! И при увеличении количества элементов в списке  разрыв по скорости растет все больше и больше! 
В Функция получения элемента мои предъидущие наблюдения не менялись, при длинне в 100000 элементов на словарь/список
словарь был в 2 раза быстрее.
В целом вывод не поменялся, словари быстрее в работе, за счет хешей
"""
