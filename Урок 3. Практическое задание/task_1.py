"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


def time_(func):
    def wrapped(*args):
        start_val = time.time()
        func(*args)
        end_val = time.time()
        print(end_val - start_val)

    return wrapped


# a)
list_ = []
dict_ = {}


@time_
def list_append(lst):
    for i in range(100000):  # O(n)
        lst.append(i)  # O(1)


@time_
def dict_add(dct):
    for i in range(100000):  # O(n)
        dct[str(i)] = i  # O(1)


list_append(list_)
dict_add(dict_)


# Заполнение списка - 0.0030558109283447266
# Заполнение словаря - 0.05355572700500488
# В данном случае список заполняется быстрее
# Так как списку не требуется вычислять хеш-ключи


# b)
@time_
def list_read(lst):
    for i in range(len(lst)):
        a = lst[i]  # O(1)


@time_
def dict_read(dct):
    for i in dct.keys():
        a = dct[i]  # O(1)


list_read(list_)
dict_read(dict_)


# Получение элемента списка по индексу - 0.012108325958251953
# Получение элемента словаря по ключу - 0.009012699127197266
# Тем самым мы видим, что получение элемента по ключу отрабатывает быстрее, так как ключи хранятся в хеше
# Но, если нам нужно просто получить элементы списка перебором, а не по индексу
# Такой перебор будет работать быстрее словаря:
# for i in lst:
#     a = i
# Время - 0.008911371231079102

# c)
@time_
def list_delete(lst):
    for i in range(len(lst)):
        lst.pop(0)  # O(1)


@time_
def dict_delete(dct):
    for i in range(len(dct)):
        dct.pop(str(i))  # O(1)


list_delete(list_)
dict_delete(dict_)

# Удаление из списка - 1.555246114730835
# Удаление из словаря - 0.05146670341491699
# Элементы по ключу в словаре удаляются намного быстрее, чем ппо индексу в списке
# Всему виной хеш-ключи
