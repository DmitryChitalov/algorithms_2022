"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

"""
Задание а)
Сложность выполнения в О-нотации у обеих операций линейная O(n)
Но при каждом запуске с одинаковым количеством элементов, словарь заполняется медленнее, это связано с тем, что операция требует время на создание записи в 
хеш-таблице. 
"""


import time
from random import randint


def time_counter(func):

    def wraper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()

        print(func.__name__, start - end)
        return result

    return wraper


@time_counter
def fill_list(n):
    """Функция заполнения списка рандомными числами"""

    list_of_num = []

    for i in range(n):
        list_of_num.append(randint(0, 10000))

    return list_of_num

@time_counter
def fill_dict(n):
    """Функция заполнения словаря рандомными числами"""

    dict_of_num = {}

    for num in range(0, n):
        dict_of_num[num] = randint(0, 10000)

    return dict_of_num


"""
Задание b)

Обращения в цикле к словарю занимают в два раза больше времени, чем обращения в списке.
У обеих функций стоимость O(n)(каждое обращение к элементу стоит O(1), но операций n), но при работе со словарем, 
нужно обращаться к хеш-таблице, искать пару: ключ-значение, а списке просто выдать очередное значение.
Если бы мы не получали все значения, а искали конкретное значение(не зная индекса в списке), то словарь выдал бы результат быстрее, т.к. не проходил бы
всю последовательность(O(1)), а списку бы пришлось пройти до результата(в худшем случае O(n)).

fill_list -63.39451861381531
fill_dict -72.47144174575806
pull_el_list -5.849710464477539
pull_el_dict -10.092776775360107
del_elem_list -5.052335500717163
del_el_dict -42.490169048309326
"""

@time_counter
def pull_el_list(lst):
    for el in lst:
        el


@time_counter
def pull_el_dict(dic):
    for key in dic.keys():
        dic[key]


"""
Задание с)
Сложность у обеих функций O(n), но удаление из словаря в цикле имеет нюанс в том, что нельзя удалить элементы по очереди, возникает
ошибка(изменение длинны словаря во время итераций), соответственно приходится создавать копию словаря или список индексов,
и проходить по ним, поэтому время выполнения удаления словаря значительно больше. 
"""


@time_counter
def del_elem_list(lst):
    """Функция удаляет элементы списка по одному"""
    for el in lst:
        del el
    # return lst

@time_counter
def del_el_dict(dic):
    """Функция удаляет элементы словаря по одному, но в цикле это сделать не представляется возможным(меняется
       длинна словаря), поэтому пришлось делать копию словаря, как вариант можно было создать список ключей,
       и пройти в цикле по ним, плюс наверняка время уходит, чтобы изменить значения в хеш-таблице
       """
    _dic = dic.copy()
    for key in _dic.keys():
        del dic[key]


list_of_num = fill_list(100000000)
dict_of_num = fill_dict(100000000)

pull_el_list(list_of_num)
pull_el_dict(dict_of_num)

del_elem_list(list_of_num)
del_el_dict(dict_of_num)

