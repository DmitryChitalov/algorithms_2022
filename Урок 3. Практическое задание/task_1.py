from time import time


def time_test(f):
    """ time measuring wrapper """

    def func(*args, **kwargs):
        before = time()
        val = f(*args, **kwargs)
        after = time()
        fname = f.__name__
        print(f'{fname} took {after - before} seconds to execute')
        return val

    return func


#  1 Заполнение списка и словаря

@time_test
def list_filling(n=50):
    return [el for el in range(0, n)]  # O(n)


@time_test
def dict_filling(n=50, m=100):
    return {k: v for k, v in zip(range(0, n), range(51, m))}  #  есть сомнения, но мне кажется, что это O(n**2) из-за zip


#  2 получение элементов списка и словаря

@time_test
def get_list_elem(my_l):  # O(n)
    for i in my_l:  # O(n)
        print(i)
    return ''


@time_test
def get_dict_elem(my_d):  # O(n)
    for k in my_d:  # O(n)
        print(f'{k}:{my_d[k]}')  # O(1)
    return ''


#  3 удаление элементов списка и словаря

@time_test
def drop_list_el(my_l):  # O(n)
    while len(my_l) != 0:  # O(n)
        my_l.pop()  # O(1)
    return my_l


@time_test
def drop_dict_el(my_d):  # O(n)
    _ = my_d.copy()  # O(n)
    for k in _:  # O(n)
        try:
            del my_d[k]  # O(1)
        except KeyError:
            pass
    return my_d


p = lambda: print('-' * 60)
l = list_filling()
d = dict_filling()

p()
print(get_list_elem(l))
p()
print(get_dict_elem(d))
p()
drop_list_el(l)
p()
drop_dict_el(d)

"""

а.  Заполнение элементами
    При заполнении словаря и списка через цикл, список показал преимущество почти
    в два раза по скорости. Возможно это связано со способом заполнения, который я выбрал,
    а возможно с тем, что элементов в словаре оказалось в два раза больше и алгоритм в два раза нагруженнее - 
    генерация ключа и значения в противовес лишь значению в списке. А может быть и то и другое сразу))
    Ну и хэш там посчитать для каждого значения в хэш-таблице в словаре тоже поди что не бесплатно,
    и стоит вычислительных ресурсов.

b.  Получение элементов
    При получении элементов через цикл списки показали на 6-8% лучший результат, чем
    словари. Допускаю, что это преимущество списков проявляется только в циклах,
    потому что помимо доступа к ключу тратятся ресурсы ещё и на получение значения ключа,
    плюс структура словарей не упорядочена, в отличие от списков, в которых итерации идут 
    последовательно от нулевого до последнего индекса. Моя гипотеза такова.

c.  Удаление элементов
    Удаление по моим замерам происходит быстрее в словаре.
    При том словари выигрывают столько же времени, сколько,
    проигрывали спискам при заполнении элементами. 
    Предполагаю, что это связано с тем, что последовательность и расположение
    элементов в словаре при удалении их части не меняется, в отличие от списка,
    элементы которого расположены в строгом порядке и новый порядок на каждой
    итерации удаления, видимо, приходится пересчитывать. 
    
                                *   *   *
                                
    Хотя провёл ещё несколько десятков тестов и понял, что всё вышесказанное - вообще чушь.
    Показатели меняются непредсказуемым образом, временами меняя картину на диаметрально противоположную.
    Допускаю, что статистика на большой дистанции вообще сравняется. Такие дела. Было занятно.

"""