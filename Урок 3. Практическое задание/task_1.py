"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

# подготовка
import time

def deco(func):
    '''декоратор для передачи атрибутов функции'''
    def wrap(values):
        start = time.time()
        res = func(values)
        stop = time.time()
        print(f'время исполнения {stop-start} секунд')
        return res
    return wrap

def deco2(func):
    def wrap():
        '''декоратор для функции без атрибутов и без return'''
        start = time.time()
        func()
        stop = time.time()
        print(f'время исполнения {stop-start} секунд')
    return wrap

quantity = 100000  # 10000000
values = [i for i in range(quantity)]
values2 = values.copy()
index_or_keys= [i for i in range(1, quantity, 20)]




# A  заполнение списка и словаря

@deco
def input_in_dict(values):
    '''сложность линейная O(N)'''
    di = {}
    for num, val in enumerate(values):  # O(N)
        di[num] = val   # O(1)
    print('заполнене словаря: ', end='')
    return di

@deco
def input_in_list(values):
    '''сложность линейная O(N)'''
    li = []
    for val in values:  # O(N)
        li.append(val)  # O(1)
    print('заполнене списка: ', end='')
    return li


di = input_in_dict(values2)
li = input_in_list(values)
'''
заполнене словаря: время исполнения 0.9937758445739746 секунд
заполнене списка: время исполнения 0.3779587745666504 секунд
Заполнение словаря происходит в 2 раза медленне чем заполнене списка т.к. при создании
нового элемента словаря срабатывет алгоритм недопущения коллизий что тратит время
'''



# B получение элемента из словаря и списка

@deco
def get_from_di(keys):
    '''сложность линейная O(N)'''
    print(f'взять из словаря по ключу: ', end='')
    for i in keys:
       res = di[i]

@deco
def get_from_di2(keys):
    '''сложность линейная O(N)'''
    print(f'взять из словаря по ключу: ', end='')
    for i in keys:
        res = di.get(i)

@deco
def get_from_li(indexes):
    '''сложность линейная O(N)'''
    print(f'взять из списка по индексу: ', end='')
    for i in indexes:
        res = li[i]
@deco
def get_from_li(indexes):
    '''сложность линейная O(N)'''
    print(f'взять из списка по индексу: ', end='')
    for i in indexes:
        res = li[i]


print('*'*30)
get_from_di(index_or_keys)
get_from_di2(index_or_keys)

get_from_li(index_or_keys)

'''
взять из словаря по ключу: время исполнения 0.0004680156707763672 секунд
взять из словаря по ключу: время исполнения 0.00038433074951171875 секунд
взять из списка по индексу: время исполнения 0.00015115737915039062 секунд

Выводы: 
1) между собой различные варианты получения из словаря по ключу примерно одинаковое время
2) Получение элемента из списка по индексу проходит в 2 раза быстрее чем из словаря
'''



# C удаление элемента списка и словаря

@deco2
def del_one_from_li():
    '''сложность константная O(1)'''
    print(f'удалить из списка по индексу: ', end='')
    del li[20]

@deco2
def remove_one_from_li():
    '''сложность константная O(1)'''
    print(f'удалить из списка по значению: ', end='')
    li.remove(40)

@deco2
def del_one_from_di():
    '''сложность константная O(1)'''
    print(f'удалить из словаря по ключу: ', end='')
    del di[20]


@deco
def pop_from_di(keys):
    '''сложность линейная O(N)'''
    print(f'многократно вырезать из словаря по ключу: ', end='')
    for i in keys:
        res = di.pop(i)

@deco
def del_from_di(keys):
    '''сложность линейная O(N)'''
    print(f'многократно удалить из словаря по ключу: ', end='')
    for i in keys:
        del di[i]


print('#'*30)
remove_one_from_li()
del_one_from_li()  # удаление всего 1 значения многократное удаление не возможно
del_one_from_di()

pop_from_di(index_or_keys)  # многократное вырезание
# del_from_di(index_or_keys)

'''Выводы
1) Многократное удаление (в цикле) из списка по индексу не выполнимо т.к. при каждом новом 
удалении список сдвигается и индексы перестраиваются
2) Многократное удаление (в цикле) из словаря возможно т.к. удаляем по ключу
3) удаление из словаря по ключу проходит быстрее в 2 раза чем удаление из списка по индексу
т.к. при удалении из списка происходит его перестроение заново с изменением индексов
4) удаление из списка по значению и по индексу примерно ровны по времени
        выкопировка из разных запусков
            удалить из списка по значению: время исполнения 3.647804260253906e-05 секунд
            удалить из списка по индексу: время исполнения 2.6702880859375e-05 секунд
            
            удалить из списка по индексу: время исполнения 3.981590270996094e-05 секунд
            удалить из списка по значению: время исполнения 2.8371810913085938e-05 секунд
5) По скорости вырезания и удаления из словаря по ключу разници нет
многократно удалить из словаря по ключу: время исполнения 0.0004086494445800781 секунд
многократно вырезать из словаря по ключу: время исполнения 0.0004584789276123047 секунд
'''