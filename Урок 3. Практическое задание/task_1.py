"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import random
import time

n = 9999999


def dec_timer(func):
    def wrapper(*args):
        start = time.time()
        res = func(*args)
        end = time.time()
        print(f"Function time execution = {end - start}")
        return res

    return wrapper


@dec_timer
def filling_task(n, obj):
    res = obj()
    for i in range(n):
        if type(res) is list:
            res.append(i)  # O(1)
        elif type(res) is dict:
            res[i] = random.randint(0, 1000)  # O(1)
    return res


print("Fillind")
ls_res = filling_task(n, list)

dict_res = filling_task(n, dict)
"""
Время выполнения одной команды вставки в лист и словарь = O(1). 
Но заполение словаря занимает намного больше времени, так как каждая вставка использует функцию хэширования, что замедляет процесс 
"""
print('Getting')


@dec_timer
def getting_task(n, obj):
    if type(obj) is list:
        for i in range(n):
            s = obj[i]  # O(1)
    elif type(obj) is dict:
        for i in range(n):
            s = obj.get(i)  # O(1)


getting_task(n, ls_res)
getting_task(n, dict_res)
"""
Время получение значения из листа быстрее, так как нет необходимости вычистлять хэш
"""
print('del_task')


@dec_timer
def del_task(n, obj):
    if type(obj) is list:
        for i in range(n):
            obj.pop()# O(1)
    elif type(obj) is dict:
        for i in range(n):
            obj.pop(i)# O(1)

del_task(n, ls_res)
del_task(n, dict_res)

# Удаление из листа и словаря схожи, так как сложность удаления в обоих структурах O(N)