"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
import time


def time_of_function(function):
    def wrapped(*args):
        start_time = time.perf_counter_ns()
        res = function(*args)
        print(f' {function.__name__} {time.perf_counter_ns() - start_time}')
        return res

    return wrapped


@time_of_function
def fill_lst(n):  # O(N)
    res = []
    for j in range(n):  # O(N)
        res.append(j)  # O(1)

    # res = [i for i in range(n)]
    return res


@time_of_function
def fill_lst_lc(n):  # O(N)
    res = [i for i in range(n)]
    return res
"""
LC стабильно быстрее чем добавление в цикле в 1,5 - 2 раза.
В LC тоже не избежно есть цикл. Объяняется это тем что LC делается на С внутри интерпретатора, которая часто гораздо выше,
чем скорость выполнения байт-кода циклов for внутри PVM.
"""


@time_of_function
def fill_dct(n):
    res = {}
    for j in range(n):  # O(N)
        res[j] = j  # O(1)

    # res = {x: x for x in range(n)}
    return res


"""
Орентировочное время заполнения словаря и списко приблизительно одинаково. Заполнение словаря чуть дольше. 
Списковое включение [i for i in range(n)] в полтора раза быстрее записи в цикле.
"""


@time_of_function
def get_lst(n, lst):  # O(N)
    for j in range(n):  # O(N)
        i = lst[j]  # O(1)


@time_of_function
def get_dct(n, dct):
    for j in range(n):  # O(N)
        i = dct[j]  # O(1)


@time_of_function
def del_lst(n, lst):  # O(N) для pop()  О(N**2) для pop(0)
    for j in range(n):  # O(N)
        lst.pop(0)  # O(N)
        # lst.pop()  # O(1)


@time_of_function
def del_dct(n, dct):
    for j in range(n):  # O(N)
        dct.pop(j)  # O(1)


n = 1000000
lst = fill_lst(n)
lst = fill_lst_lc(n)

# dct = fill_dct(n)
#
# get_lst(n, lst)
# get_dct(n, lst)
#
# del_lst(n, lst)
# del_dct(n, dct)

# Наверно я что то делаю не так. Но все показатели для списков и словарей приблизительно одинаковы, кроме случая
# удаления списка по индексу.
# Теоретически....
#      1) Запись в словарь должна быть значительно дольше из за того, что необходимо расчитывать хеш, по сравнению с
#  списками. У списков запись быстрая - записать один элемент в конец объекта, кроме случая когда переполняется
#  выделенная под массив память и необходимо время на новое выделение памяти.
#      2) Доступ по ключу словаря должен быть очень быстрым из того, что "под капотом" там хеш таблицы.
#      3) Удаление в словаре - быстрое. В списке, если удаление с конца, то тоже быстрое. Если с начала,
# то необходимо время для перестройки массива. Вот это у меня подтвердить получилось. Сложность О(N**2)
