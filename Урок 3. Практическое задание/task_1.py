"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно проводить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно проводить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time
from random import randint


# from random import randrange, sample


# Декоратор - вычисление времени
def calc_time(func):                    # O(1)
    def wrapper(*args, **kwargs):
        start = time.time()
        res = func(*args, **kwargs)
        end = time.time()
        print('Время выполнения функции {}: {} секунд.'.format(func.__name__, end - start))
        return res

    return wrapper


# -------------------------------------------------------------------------------------------------
# # a) Заполнение списка / словаря

# Список
@calc_time
def add_in_list(lst_1, lst_2):      # O(n)
    for el_2 in lst_2:              # O(n)
        lst_1.append(el_2)          # O(1)


@calc_time
def ins_in_list(lst_1, lst_2):      # O(n)
    for el_2 in lst_2:              # O(n)
        lst_1.insert(0, el_2)          # O(n)



@calc_time
def add_in_dict(dict_1, dict_2):            # O(2*n)   -- порядок сложности O(n)
    for key_2, val_2 in dict_2.items():         # O(2*n)
        dict_1[key_2] = val_2                   # O(1)


lst_1 = [randint(5, 1000) for i in range(0, 200)]
lst_2 = [randint(5, 1000) for i in range(0, 300000)]

dict_1 = {i: randint(5, 1000) for i in range(0, 200)}
dict_2 = {i: randint(5, 1000) for i in range(0, 300000)}


print(add_in_list(lst_1, lst_2))
print(add_in_dict(dict_1, dict_2))
print(ins_in_list(lst_1, lst_2))

# аналоги
# lst_1.extend(lst_2)
# dict_1.update(dict_2)

# Выводы
# Время выполнения функции add_in_list: 0.015559911727905273 секунд.
# Время выполнения функции add_in_dict: 0.04686474800109863 секунд.
# Время выполнения функции ins_in_list: 94.86826992034912 секунд.
# по замерам времени - заполнение списка (append) быстрее, чем для словаря , т.к. словарь - хэш таблица, и требуется дополнительное время для вычисления хэша
# сложность у операция - одинаковая O(1)
# метод списка  insert() - намного медленее, т.к. сложность O(n)
# ------------------------------------------------------------------------------------------------------------


# # b) Получение элемента из списка / словаря

@calc_time
def get_el_lst(lst):                # O(n)
    for i in range(len(lst)):       # O(n)
        el = lst[i]                  # O(1)

@calc_time
def get_el_dict(dct):          # O(n)
    for key in dct.keys():      # O(n)
        el = dct[key]           #O(1)

lst = [randint(0, 10000) for i in range(0, 2000000)]
dct = {i: randint(0, 10000) for i in range(0, 2000000)}

print(get_el_lst(lst))
print(get_el_dict(dct))

# Выводы:
# Время выполнения функции get_el_lst: 0.09372973442077637 секунд.
# Время выполнения функции get_el_dict: 0.0624849796295166 секунд.
# Для словаря - операции быстрее, чем для списка,т.к. словарь - хэш-таблица, нахождение элемента - быстрее
# Сложность операций м для словаря и для списка - O(1)
# ----------------------------------------------------------------------------------------------------

# # c) Удаление элемента из списка / словаря
@calc_time
def pop_lst(lst):                        #O(n)
    for i in range(len(lst)):          # O(n)
        lst.pop()                       #O(1)
    return lst

@calc_time
def pop_dict(dct):              # O(n)
    dct_copy = dict(dct)         # O(n)
    for key in dct.keys():        # O(n)
        dct_copy.pop(key)       # O(1)


lst = [randint(0, 10000) for i in range(0, 2000000)]
dct = {i: randint(0, 10000) for i in range(0, 2000000)}

print(pop_lst(lst))
print(pop_dict(dct))

# Выводы:
# Время выполнения функции pop_lst: 0.14059019088745117 секунд.
# Время выполнения функции pop_dict: 0.28117966651916504 секунд.
# Для списка - операции быстрее, чем для словаря,т.к. словарь - хэш-таблица, поиск - по ключу медленее (требуется вычисление хэша -> дополнительное время), чем по индексу списка
# Сложность операций м для словаря и для списка - O(1)
