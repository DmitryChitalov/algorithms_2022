"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

from time import perf_counter_ns


def timer(func):
    """
    Небольшой декоратор для замеров времени работы функции. Используем версию с наносекундами, что бы наблюдать
    комфортные для восприятия цифры, а не вида 0.00000000000000е-1 и т.п.
    """

    def wrapper(*args, **kwargs):
        start = perf_counter_ns()
        res = func(*args, **kwargs)
        print(f'Функция {func.__name__} выполнена за {perf_counter_ns() - start} наносекунд')
        return res

    return wrapper


# Часть а:
@timer
def list_input(n):
    """
    В функции заполнения списков используем генератор списков. Значение n которое принимает функция -
    количество элементов списка Итоговая сложность функции O(n).
    """
    my_list = [n + 1 for n in range(n)]
    return my_list


@timer
def dict_input(n):
    """
    В функции заполнения словарей используем генератор словарей. Значение n которое принимает функция -
    количество элементов списка Итоговая сложность функции O(n).
    """
    my_dict = {n + 1: n + 1 for n in range(n)}
    return my_dict


# Часть b:

@timer
def get_list_el(user_list, n):
    """
    Функция принимает список, номер элемента списка, и возвращает значение элемента
    """
    return user_list[n]


@timer
def get_dict_el(user_dict, n):
    """
    Функция принимает словарь, ключ, и возвращает значение ключа Итоговая сложность функции O(1)
    """
    return user_dict[n]


# Часть с:

@timer
def del_list_el(user_list, n):
    """
    Функуия принимает список и номер элемента для удаления, и возвращает список без удаляемого элемента
    Итоговая сложность функции O(n)
    """
    new_list = user_list.copy()
    new_list.pop(n)
    return new_list


@timer
def del_dict_el(user_dict, n):
    """
    Функция принимает словарь и ключ, удаляет элемент по ключу, и возвращает словарь без удаляемого элемента
    Итоговая сложность функции O(n)
    """
    new_dict = user_dict.copy()
    new_dict.pop(n)
    return new_dict


"""
Запускаем на исполнение следующие команды (я запускал раз ~ 10, результаты замера таймера в комментах):
"""
a = list_input(5)  # 2600 - 5800 нс
b = dict_input(5)  # 1600 - 3400 нс
# В целом генерация словаря идет по замерам ощутимо быстрее где то на 1000 - 2000 нс
print(a)  #
print(b)  #
print(get_list_el(a, 3))  # 300 - 800
print(get_dict_el(b, 3))  # 300 - 600
# В этих замерах функции очень часто показывалиодинаковые результаты. но в половине случаев
# получение элемента из словаря было быстрее на 100 нс
print(del_list_el(a, 3))  # 1200 - 2600
print(del_dict_el(b, 3))  # 1100 - 2200
# И тут словарь занимает лидирующие позиции в среднем опережая по скорости на 100 - 500 нс список!
# При одинаково сложности функций согласно O-нотации, делаем однозначный вывод: Словари - скорость!
# И все благодаря хешам)
