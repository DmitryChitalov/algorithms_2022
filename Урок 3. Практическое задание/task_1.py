"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time


def timer(func):
    def wrapper(*args):
        start_time = time.perf_counter_ns()
        return_ = func(*args)
        print(f'{time.perf_counter_ns() - start_time} нс')
        return return_

    return wrapper


# a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
#    заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
#    сделайте аналитику, что заполняется быстрее и почему
#    сделайте замеры времени
COUNT = 100000


@timer
def list_append(lst: list):  # Общая сложность O(1)
    for i in range(COUNT):  # O(1)
        lst.append(i)  # O(1)


@timer
def list_insert(lst: list):  # Общая сложность O(n)
    for i in range(COUNT):  # O(1)
        lst.insert(len(lst), i)  # O(n)


@timer
def dict_filling(dct: dict):  # Общая сложность O(1)
    for i in range(COUNT):  # O(1)
        dct[i] = i + 1  # O(1)


@timer
def dict_setdefault_filling(dct: dict):  # Общая сложность O(1)
    for i in range(COUNT):  # O(1)
        dct.setdefault(i, i + 1)  # O(1)


lst_ = list()
dct_ = dict()
print('Заполнение списка через list.append: ')
list_append(lst_[:])
print('Заполнение списка через list.insert: ')
list_insert(lst_)
print('Заполнение словаря передачей значения по ключу: ')
dict_filling(dct_.copy())
print('Заполнение словаря через метод dict.setdefault: ')
dict_setdefault_filling(dct_)
"""
Заполнение списка через list.append:
187500 нс
Заполнение списка через list.insert:
284900 нс
Заполнение словаря передачей значения по ключу:
263400 нс
Заполнение словаря через метод dict.setdefault:
287500 нс
_________________________________________________________________________________________________________
Вывод:
В среднем словарь заполняется в 1.5 раза дольше, чем список из-за хэширования ключей.
Операция list.insert отрабатывает хуже, чем append при классическом заполнении (вставке в конец), т.к.
обращается к позиции по индексу. Чем длиннее список, тем дольше будет отрабатывать insert

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
"""


@timer
def list_searcher(lst: list):  # O(1)
    for i in range(COUNT):  # O(1)
        lst[i] = 'change'  # O(1)


@timer
def dict_searcher(dct: dict):  # O(1)
    for i in range(COUNT):  # O(1)
        dct[i] = 'change'  # O(1)


print('Перебор элементов списка: ')
list_searcher(lst_)
print('Перебор элементов словаря: ')
dict_searcher(dct_)

"""
Перебор элементов списка: 
86500 нс
Перебор элементов словаря: 
98100 нс
_________________________________________________________________________________________________________
Вывод:
Изменение элементов в словаре происходит медленнее, чем в списке, т.к. при обращении по ключу его нужно
хэшировать для поиска связанного с ним значения. В списке же обращение идет напрямую через индекс
"""


# с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
#    удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
#    сделайте аналитику, что заполняется быстрее и почему
#    сделайте замеры времени


@timer
def list_pop(lst: list):  # O(n)
    for i in range(0, COUNT, -1):  # O(1)
        lst.pop()  # O(n)


@timer
def list_pop_i(lst: list):  # O(n)
    for i in range(0, COUNT, -1):  # O(1)
        lst.pop()  # O(n)


@timer
def dict_pop(dct: dict):
    for i in range(0, COUNT, -1):  # O(1)
        dct.pop(i)  # O(1)


@timer
def dict_popitem(dct: dict):
    for i in range(0, COUNT, -1):  # O(1)
        dct.popitem()  # O(1)


print('Удаление элементов списка с помощью метода list.pop: ')
list_pop(lst_[:])
print('Удаление элементов словаря с помощью метода dict.popitem: ')
dict_popitem(dct_.copy())
print('Удаление элементов списка с помощью метода list.pop(i): ')
list_pop(lst_[:])
print('Удаление элементов словаря с помощью метода dict.pop(i): ')
dict_pop(dct_.copy())


"""
Удаление элементов списка с помощью метода list.pop: 
1600 нс
Удаление элементов словаря с помощью метода dict.popitem: 
2200 нс
Удаление элементов списка с помощью метода list.pop[i]: 
900 нс
Удаление элементов словаря с помощью метода dict.pop: 
2900 нс

_____________________________________________________________________________________________
Вывод:
dict.popitem отрабатывает быстрее, чем list.pop (как и должно быть по алгоритмической сложности)
А dict.pop(i) возвращает значение по ключу, поэтому отрабатывает медленнее, т.к. требуется посчитать хэш, в отличии
от list.pop
"""
