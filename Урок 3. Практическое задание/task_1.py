"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""
"""Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""


# a)
def benchmark(func):
    import time

    def wrapper(*args, **kwargs):
        start = time.time()
        return_value = func(*args, **kwargs)
        end = time.time()
        print(f'{end - start}')
        return return_value
    return wrapper


@benchmark
def add_list(el): #O(n)
    """
    заполнение списка количеством элементов el
    """
    for item in range(el): #O(n)
        my_list.append(item) #O(1)
    return f'Заполнение списка'#O(1)


@benchmark
def add_dict(el):  #O(n)
    """
    заполнение словаря значениями и ключами el раз
    """
    for item in range(el): #O(n)
        my_dict[item] = item #O(1)
    return f'Заполнение словаря'#O(1)



# б)
@benchmark
def get_el_list(el):#O(n)
    for i in range(len(my_list)):#O(n)
        if el == my_list[i]:#O(1)
            return f'Получение элемента списка (через цикл). Элемент - {el}'#O(1)

@benchmark
def get_el_dict(el):#O(n)
    for v in my_dict.values():#O(n)
         if v == el:#O(1)
             return f'Получение элемента словаря (через цикл). Элемент - {el}'#O(1)

# c)
@benchmark
def del_el_list(el):#O(n^2)
    for i in range(len(my_list)):#O(n)
        if my_list[i] == el:#O(1)
            my_list.pop(el)#O(n)
            # print(my_list)
            return f'удаление элемента списка (через цикл). Элемент - {el}'#O(1)

@benchmark
def del_el_dict(el):#O(n)
    for v in my_dict.values():#O(n)
        if v == el:#O(1)
            my_dict.pop(el)#O(1)
            # print(my_dict)
            return f'удаление элемента словаря (через цикл). Элемент - {el}'  # O(1)


my_list = []
my_dict = {}
print(add_list(10_000_000))
print(add_dict(10_000_000))
print(get_el_list(1_000_000))
print(get_el_dict(1_000_000))
print(del_el_list(2_000_000))
print(del_el_dict(2_000_000))

# Работа со словарем предсказуемо быстрее.

