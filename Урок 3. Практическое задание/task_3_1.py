"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""


import time


def time_counter(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        # print('start = ', start)
        func(*args, **kwargs)
        end = time.time()
        # print('end = ', end)
        # print(f'{func.__name__} выполняется {end - start} секунд')
        # print()
        return end - start
    return wrapper


test_lst = []
test_dict = {}


@time_counter
def list_append(num, lst):  # O(N)
    lst.clear()  # O(1)
    for i in range(num):  # O(N)
        lst.append(i)  # O(1)
    return lst


@time_counter
def dict_append(num, test_dict):  # O(N)
    test_dict.clear()
    for i in range(num):  # O(N)
        test_dict[i] = i  # O(1)
    return test_dict


n = 100_000  # Количество добавляемых элементов
repeats = 10  # Количество повторений заполнений списка и словаря для усреднения результатов измерений

sum_time = 0
for counter in range(repeats):
    sum_time += list_append(n, test_lst)
print(f'Список в {n} элементов заполняется {repeats} раз за {sum_time} сек')

sum_time = 0
for counter in range(repeats):
    sum_time += dict_append(n, test_dict)
print(f'Словарь в {n} элементов заполняется {repeats} раз за {sum_time} сек')

# Список обычно (но не всегда) заполняется чуть быстрее, чем словарь. Вероятно потому что не требуется расчет хэша
# при добавлении элемента.


@time_counter
def list_reader(lst):  # O(N)
    test_var = 0
    for i in range(len(lst)):  # O(N)
        test_var = lst[i]  # O(1)
    # print(test_var)


print('\n', '*' * 100)
print(f'Список длиной {len(test_lst)} элементов читается за {list_reader(test_lst)} сек')


@time_counter
def dict_reader(dic):  # O(N)
    test_var = 0
    for i in range(len(dic)):  # O(N)
        test_var = dic[i]  # O(1)
    # print(test_var)


print(f'Словарь длиной {len(test_dict)} элементов читается за {dict_reader(test_dict)} сек')

# Список читается немного быстрее, чем словарь. Вероятно, потому что словарь более тяжеловесная структура


@time_counter
def list_cleaner(lst):  # O(N**2)
    while lst:  # O(N)
        lst.pop(0)  # O(N)
    print(f'Из списка {lst.__ne__} удалены все элементы. В списке {len(lst)} элементов')


@time_counter
def dict_cleaner(dic):  # O(N)
    while dic:  # O(N)
        dic.popitem()  # O(1)
    print(f'Из словаря удалены все элементы. В словаре {len(dic)} элементов')


print('\n', '*' * 100)
print(f'Список длиной {len(test_lst)} элементов очищается за {list_cleaner(test_lst)} сек')
print(f'Словарь длиной {len(test_dict)} элементов очищается за {dict_cleaner(test_dict)} сек')


# Словарь очищается намного быстрее, т.к. при вырезании из списка элемента методом .рор приходится
# пересчитывать все индексы в списке. Таким образом на каждом шаге цикла (O(N)) добавляется ещё одна
# процедура (O(N))
# А при вырезании элемента из словаря ничего пересчтывать не приходится.