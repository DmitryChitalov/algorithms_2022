"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""

from timeit import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def my_func(nums):
    return [el for el in range(len(nums)) if nums[el] % 2 == 0]


print(func_1([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9]))
print(f"Замер func_1 >>> "
      f"{timeit('func_1', setup='from __main__ import func_1', number=50000000)}")
# Замер func_1 >>> 0.7996113
print(my_func([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9]))
print(f"Замер my_func >>> "
      f"{timeit('func_1', setup='from __main__ import func_1', number=50000000)}")
# Замер my_func >>> 0.7214709000000001

"""Произведены замеры времени функции из задания(итератор с функцией append) и 
оптимизированной мною функции (list comprehension), количество замеров == 50000000.
Результат показал, что оптимизированная функция выполнилась с наименьшими временными затратами,
так как генератор списков, по умолчанию, работает шустрее for-циклов.
"""
