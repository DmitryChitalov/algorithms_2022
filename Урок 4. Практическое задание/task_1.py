"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""
from timeit import timeit
def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)

    return new_arr

def func_2(nums):
    return [i for i in range(len(nums)) if nums[i] % 2 == 0] # list comprehension вместо цикла.


print(func_1([2, 2, 3, 6, 5, 5, 5, 8]))

print(func_2([2, 2, 3, 6, 5, 5, 5, 8]))

print(timeit("func_1([2, 2, 3, 6, 5, 5, 5, 8])", globals=globals(), number=9000000))
print(timeit("func_2([2, 2, 3, 6, 5, 5, 5, 8])", globals=globals(), number=9000000))

"""
[0, 1, 3, 7] результат работы func_1 со списком [2, 2, 3, 6, 5, 5, 5, 8]
[0, 1, 3, 7] результат работы func_2 со списком [2, 2, 3, 6, 5, 5, 5, 8]
0.1407704150005884 время выполнения функции func_1 со списком [2, 2, 3, 6, 5, 5, 5, 8] 100000 раз 
0.126616171997739 время выполнения функции func_2 со списком [2, 2, 3, 6, 5, 5, 5, 8] 100000 раз

11.284280764997675 время выполнения функции func_1 со списком [2, 2, 3, 6, 5, 5, 5, 8] 9000000 раз
11.979701835000014 время выполнения функции func_2 со списком [2, 2, 3, 6, 5, 5, 5, 8] 9000000 раз
При многократном повторении оптимизация не работает и даже наоборот: list compehension работает хуже, чем простой цикл.


"""