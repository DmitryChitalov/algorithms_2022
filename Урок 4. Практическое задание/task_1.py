"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""

from timeit import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


def func_2(nums):
    return [idx for idx, val in enumerate(nums) if val % 2 == 0]


# nums_1000
# 0.14847147500040592
# 0.11846800500097743
# ----------------------------------------------------------------------------------------------------
# nums_10000
# 1.2935487750000902
# 1.083344427999691
# ----------------------------------------------------------------------------------------------------
# nums_100000
# 13.302568819999578
# 11.620029615000021


"""
Произвел профилирование func_1.
Добиться прироста во времени выполнения можно если использовать
списковое включение, оно выполняется быстрее, так как реализованно на языке С
и смотрится локаничнее и понятнее.
Bторовое профилирование func_2.Сразу виден прирост
в скорости выполнения нашего алгоритма.
Следовательно оптимизация с помощью спискового включения можно считать
лучшим вариантом(подтверждено профилированием)
"""
