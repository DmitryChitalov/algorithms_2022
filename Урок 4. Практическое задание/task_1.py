"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры

ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""
from timeit import timeit


def func_1(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


# пытаюсь "оптимизировать" код, используя списковые включения
def func_2(nums):
    return [x for x in range(len(nums)) if nums[x] % 2 == 0]


print(func_1([1, 2, 3, 4]))  # [1, 3]
print(func_2([1, 2, 3, 4]))  # [1, 3]

print(timeit('func_1([1,2,3,4])', globals=globals()))  # 0.487360900035128
print(timeit('func_2([1,2,3,4])', globals=globals()))  # 0.580850400030613
# тут я запаниковал, так как получается мой "оптимизированный" код сработал дольше
# и решил проверить на более большом списке
check_list = [1, 2, 3, 4, 5, 6, 50, 51, 52, 60, 61, 62, 63, 65, 66, 67, 78, 80, 90, 91]
print(timeit('func_1(check_list)', globals=globals()))  # 1.5042954999953508
print(timeit('func_2(check_list)', globals=globals()))  # 1.3460246999748051

'''
А теперь моя мощная аналитика. Сложность func_1 и func_2 одинаковая - O(n), но при этом в первой функции есть метод
append, добавляющий элемент в конец списка. Сложность append O(1) - константа, что незаметно при небольших списках.
Но становится видно на списках с большим количеством элементов. Вывод: несмотря на то, что метод append имеет O(1)-
сложность, при работе с большими массивами даже такая сложность сказывается на скорости выполнения кода.
'''
