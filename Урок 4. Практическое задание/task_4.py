"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Обязательно напишите третью версию (здесь возможно даже решение одной строкой).
Сделайте замеры и опишите, получилось ли у вас ускорить задачу.
"""
import random
from timeit import timeit

array = [1, 3, 1, 3, 4, 5, 1]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'

def func_3():
    max_3 = max(zip((array.count(item) for item in set(array)), set(array)))

    return f'Чаще всего встречается число {max_3[1]}, ' \
           f'оно появилось в массиве {max_3[0]} раз(а)'

print(func_1())
print(func_2())
print(func_3())


print('func_1', {timeit(f'func_1()', globals=globals(), number=100000)})
print('func_2', {timeit(f'func_2()', globals=globals(), number=100000)})
print('func_3', {timeit(f'func_3()', globals=globals(), number=100000)})

'''

Первая функция быстрее, второй потому, т.к. в ней предусмотрен дополнительный список
третий вариант дольше, т.к. там идет работа с несколькими множествами и встроенными одна в другую функциями 

Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
Чаще всего встречается число 1, оно появилось в массиве 3 раз(а)
func_1 {0.11207889999999998}
func_2 {0.15218370000000003}
func_3 {0.17079069999999996}

мы получаем коллекцию, не содержащую повторяющихся элементов, используя set.
x = ['a','a','b','c','b','a']
>>> set(x)
{'a', 'c', 'b'}
Затем мы подсчитываем, сколько раз каждый элемент находится в x. Это вернет объект генератора, 
вы можете сделать его списком, чтобы увидеть его значения (используя "[ ... ]" вместо "( ...)"), он вернет [3, 1, 2].

>>> (x.count(item) for item in set(x))

Затем мы берем подсчеты и соединяем их с элементами, используя zip.
 Количество вхождений сначала, для следующего шага. Вы можете увидеть его значение, 
 используя list( ... ) на нем, он вернет [(3, 'a'), (1, 'c'), (2, 'b')] для  используя list( ... ) на нем, 
 он вернет [(3, 'a'), (1, 'c'), (2, 'b')] 

>>> zip((x.count(item) for item in set(x)), set(x))
Наконец, мы находим, какая из пар встречается чаще всего, используя max.

>>> max(zip((x.count(item) for item in set(x)), set(x)))
(3, 'a')

'''