"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Обязательно напишите третью версию (здесь возможно даже решение одной строкой).
Сделайте замеры и опишите, получилось ли у вас ускорить задачу
"""

from timeit import timeit, repeat, default_timer

array = [1, 3, 1, 3, 4, 5, 1]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'

def func_3():
    new_array = [array.count(num) for i, num in enumerate(array)]
    max_3 = max(new_array)
    elem = array[new_array.index(max_3)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_3} раз(а)'


def func_4():
    elem = max(set(array), key=array.count)
    max_4 = array.count(elem)
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_4} раз(а)'


setup = '''
from random import randint
from __main__ import func_1, func_2, func_3, func_4, array
'''


functions = [
    'func_1()',
    'func_2()',
    'func_3()',
    'func_4()'
    ]

for func in functions:
    result = repeat(func, setup, default_timer, 5, 2000)
    print(func[:-2])
    print(result)
    print('Берем минимальное число - ' + str(min(result)))


'''
Написала еще 2 функции (func_3 не очень нравится, но оставила для сравнения). Через одну строчку не получилось, но близко.

Мои результаты:

func_1
[0.003090819000135525, 0.0030550030005542794, 0.0029661880016647046, 0.0029430539998429595, 0.0030028990004211664]
Берем минимальное число - 0.0029430539998429595
func_2
[0.0038651939994451823, 0.003861310999127454, 0.003751513999304734, 0.003769782000745181, 0.003834357999949134]
Берем минимальное число - 0.003751513999304734
func_3
[0.004100926998944487, 0.004052544998558005, 0.004035308000311488, 0.003990983999756281, 0.0043417670003691455]
Берем минимальное число - 0.003990983999756281
func_4
[0.0030337429998326115, 0.0028815829991799546, 0.0029662420001841383, 0.0029924390000815038, 0.003150188998915837]
Берем минимальное число - 0.0028815829991799546

Получается что от самой эффективной функции к наименее эффективной:
func_4 = func_1 -> func_2 -> func_3

У func_1 и func_4 функций очень похожие замеры, пока тестировала, периодически func_1 отрабатывала быстрее, но в целом результаты были лучше у func_4
'''
