"""
Задание 4.

Приведены два алгоритма. В них определяется число,
которое встречается в массиве чаще всего.

Сделайте профилировку каждого алгоритма через timeit

Обязательно напишите третью версию (здесь возможно даже решение одной строкой).
Сделайте замеры и опишите, получилось ли у вас ускорить задачу
"""
from timeit import timeit, repeat, default_timer

array = [1, 3, 1, 3, 4, 5, 1]


def func_1():
    m = 0
    num = 0
    for i in array:
        count = array.count(i)
        if count > m:
            m = count
            num = i
    return f'Чаще всего встречается число {num}, ' \
           f'оно появилось в массиве {m} раз(а)'


def func_2():
    new_array = []
    for el in array:
        count2 = array.count(el)
        new_array.append(count2)

    max_2 = max(new_array)
    elem = array[new_array.index(max_2)]
    return f'Чаще всего встречается число {elem}, ' \
           f'оно появилось в массиве {max_2} раз(а)'


def func_3():
    return max(array, key=lambda i: array.count(i))


print('func_1: ', timeit("func_1()", globals=globals(), number=100000))
print('func_2: ', timeit("func_2()", globals=globals(), number=100000))
print('func_3: ', timeit("func_3()", globals=globals(), number=100000))

statements = ['func_1()', 'func_2()', 'func_3()']
setup = "None"
for st in statements:
    res = repeat(st, setup, default_timer, 5, 1000000, globals=globals())
    print(res)
    print(min(res))

"""
Как то тяжеловато, но все таки получилось сделать однострочный вариант решения! 
Для оценки  быстродействия будем использовать не самый ходовой метод, проведем 5 замеров по 10000 запусков функций.
Мои результаты замеров:
[0.009083600016310811, 0.00918429996818304, 0.009070600033737719, 0.009105999954044819, 0.009028100059367716]
0.009028100059367716  - минимальное время для func_1()
[0.011715800035744905, 0.014823799952864647, 0.017502999980933964, 0.013813300058245659, 0.012834600056521595]
0.011715800035744905  - минимальное время для func_2()
[0.012462800019420683, 0.01047510001808405, 0.011149500031024218, 0.010679700062610209, 0.010610500001348555]
0.01047510001808405  - минимальное время для func_3()
И вот тут, с удивлением, я обнаруживаю, что мой однострояъчный вариант  не такой уж и быстрый... Ускорить не получилось,
первый вариант самый быстродейственный.
Вариант с 1000000 повторений кода в замере:
[0.9230491999769583, 0.8923419000348076, 0.8899359999923036, 0.8909178000176325, 0.8877135999500751]
0.8877135999500751
[1.2007159000495449, 1.1871799000073224, 1.1906611000886187, 1.1907981999684125, 1.216364899999462]
1.1871799000073224
[1.0544780999189243, 1.0619536999147385, 1.0617347999941558, 1.063469999935478, 1.0582519999006763]
1.0544780999189243
Тенденция сохраняеться, выводы оставляю прежними
"""
