"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (в материалах есть его описание)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
"""
from timeit import timeit

def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i), timeit('simple(i)', globals=globals(), number=1000))


# n - количество чисел в генерируемом списке простых чисел, k - позиция искомого числа
def eratosthenes(k, n=10000):
    prime_lst = []
    prime = [True for i in range(n + 1)]
    x = 2
    while x ** 2 <= n:
        if prime[x]:
            for i in range(x ** 2, n - 1, x):
              prime[i] = False
        x += 1

    for p in range(2, n + 1):
        if prime[p]:
            prime_lst.append(p)

    return prime_lst[k - 1]


k = int(input('Введите порядковый номер искомого простого числа: '))
print(eratosthenes(k), timeit('eratosthenes(k, 30)', globals=globals(), number=1000))

# Замеры: 10е число - 0.0087 сек и 0.804 сек соотв., 100е - 1.08 сек и 0.83 сек, 1000е - 1.7 сек всего на number=10 и
# 0.816 на number=1000 соответсвенно.
# Если вручную менять количество генерируемых элементов в массиве простых чисел,
# можно добиться оптимальной производительности даже для небольших значений n (например, сгенерировать список всего из
# 30 чисел для поиска десятого простого). Однако, это противоречит задаче, когда по условию мы не знаем на какой
# позиции находится искомое число. Генерируя больший массив чисел (у меня 10000), большой прирост скорости наблюдается
# уже на n=100, не говоря про n=1000. Это связано с тем, что сложность перебора - O(n**2), а решета -
# линейно-логарифмическая
