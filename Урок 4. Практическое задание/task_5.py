"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (в материалах есть его описание)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
"""

"""
ВЫВОДЫ:
Я полагаю, что алгоритм Эратосфена не применим для решения данной задачи, т.к. алгоритм работает на отрезке
и для точного ответа на вопрос: есть ли на отрезке нужное количество простых чисел? Нужно это количество знать заранее)
В википедии описан вариант последовательной генерации, но он пока за гранью моего понимания и там же написано, 
что он сильно плох по скорости. Наверное можно прибавляя какой-то интервал) пока не найдешь нужное количество.
 
Сам алгоритм я реализовал, вроде он не сложный, эмпирически подобрал значения отрезков, сделал замеры.

Т.н. наивный алгоритм имеет сложность О(n^2) в то время как решето O(nlog(logn)), поэтому он очень быстро деградирует 
по производительности с ростом числа итераций. Алгоритмы сравнимы только на n = 10, на 100 уже выигрыш в 3-4 раза, 
а на 1000 уже в 10 раз. 

Получается что в малых дипазаонах можно использовать перебор делителей, но там простых чисел не много, я думаю их
эффективнее просто запомнить). Единственное известное мне прикладное использование простых чисел это криптография, 
но там порядки чиcел намного больше, использовать там наивный алгоритм не получится вовсе.
"""
from timeit import default_timer, timeit


def time_it(func):
    def wrapper(numb):
        start_time = default_timer()
        n = func(numb)
        print(default_timer() - start_time)
        return n
    return wrapper


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosfen(b, n):
    result = list(range(1, b + 1))
    result[0] = False
    for i in range(2, int(b ** 0.5) + 1):
        for j in range(i, len(result)):
            if result[j]:
                if result[j] % i == 0:
                    result[j] = False
    return [i for i in result if i][n - 1]


if __name__ == '__main__':

    print(f'Вариант simple(10): {timeit("simple(10)", number=1000, globals=globals())}')
    print(f'Вариант simple(100): {timeit("simple(100)", number=1000, globals=globals())}')
    print(f'Вариант simple(1000): {timeit("simple(1000)", number=1000, globals=globals())}')
    print('-'*20)
    print(f'Вариант eratosfen(30): {timeit("eratosfen(30, 10)", number=1000, globals=globals())}')
    print(f'Вариант eratosfen(542): {timeit("eratosfen(541, 100)", number=1000, globals=globals())}')
    print(f'Вариант eratosfen(7920): {timeit("eratosfen(7925, 1000)", number=1000, globals=globals())}')

