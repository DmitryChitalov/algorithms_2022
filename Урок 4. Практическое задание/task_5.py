"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (в материалах есть его описание)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
"""
from timeit import timeit


def simple(i):
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def func(i):
    d = []
    sieve = set(range(2, 10000))
    count = 0
    while sieve:
        prime = min(sieve)
        d.append(prime)
        count += 1
        sieve -= set(range(prime, 10000, prime))
        if count == i:
            break
    return d[i-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i), timeit(
    'simple(i)', 'from __main__ import simple, i', number=100
))
print(func(i), timeit(
    'func(i)', 'from __main__ import func, i', number=100
))
'''
Я взял 100 повторений т.к. при i == 1000 решение 1-ого варианта слишком долгое.
При i == 10 и i == 100 мой вариант проигрывает по скорости, но при i == 1000 он значительно быстрее.
Чем больше порядковый номер искомого простого числа тем эффективней мой вариант по отношению к 1-ому.

i == 10
29 0.0034849999999999604
29 0.3808997999999999

i == 100
541 0.2974203000000002
541 0.7528537999999996

i == 1000
7919 32.0452612
7919 4.6641943999999995
'''