"""
Задание 1.

Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python

На каждый скрипт нужно два решения - исходное и оптимизированное.

Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler

Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler

Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.


ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.

Это файл для первого скрипта
"""
from random import sample
from memory_profiler import profile
import numpy as np

##############################################################################


@profile
def check_1(lst_obj):
    """Функция должна создать множество из списка.

    Алгоритм 1:
    Создать множество из списка

    Сложность: # O(n) линейное
    """
    lst_to_set = set(lst_obj)  # O(n) линейное
    return lst_to_set          # O(1) константаное

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     37     20.6 MiB     20.6 MiB           1   @profile
#     38                                         def check_1(lst_obj):
#     39                                             """Функция должна создать множество из списка.
#     40
#     41                                             Алгоритм 1:
#     42                                             Создать множество из списка
#     43
#     44                                             Сложность: # O(n) линейное
#     45                                             """
#     46     21.2 MiB      0.6 MiB           1       lst_to_set = set(lst_obj)  # O(n) линейное
#     47     21.2 MiB      0.0 MiB           1       return lst_to_set          # O(1) константаное


##############################################################################


@profile
def check_2(lst_obj):
    """Функция должная вернуть True, если все элементы списка различаются.

    Алгоритм 2:
    Проходимся по списку и для каждого элемента проверяем,
    что такой элемент отстутствует
    в оставшихся справа элементах

    Сложность: # O(n**2) квадратичное .
    """
    for j in range(len(lst_obj)):          # O(n) линейное
        if lst_obj[j] in lst_obj[j+1:]:    # O(n) линейное
            return False                   # O(1) константаное
    return True                            # O(1) константаное

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     51     20.6 MiB     20.6 MiB           1   @profile
#     52                                         def check_2(lst_obj):
#     53                                          """Функция должная вернуть True, если все элементы списка различаются.
#     54
#     55                                             Алгоритм 2:
#     56                                             Проходимся по списку и для каждого элемента проверяем,
#     57                                             что такой элемент отстутствует
#     58                                             в оставшихся справа элементах
#     59
#     60                                             Сложность: # O(n**2) квадратичное .
#     61                                             """
#     62     20.9 MiB      0.0 MiB       10001       for j in range(len(lst_obj)):          # O(n) линейное
#     63     20.9 MiB      0.3 MiB       10000           if lst_obj[j] in lst_obj[j+1:]:    # O(n) линейное
#     64                                                     return False                   # O(1) константаное
#     65     20.9 MiB      0.0 MiB           1       return True                            # O(1) константаное


##############################################################################


@profile
def check_3(lst_obj):
    """Функция должная вернуть True, если все элементы списка различаются.

    Алгоритм 3:
    Вначале выполним для списка сортировку, далее, сравниваем элементы попарно
    Если присутствуют дубли, они будут находиться рядом.

    Сложность: # O(n log n)  линейно-логарифмическое
    """
    lst_copy = list(lst_obj)                 # Список с (n) количеством элементов O(n) линейное
    lst_copy.sort()                          # O(n log n)  линейно-логарифмическое
    for i in range(len(lst_obj) - 1):        # O(n) линейное
        if lst_copy[i] == lst_copy[i+1]:     # O(1) константаное
            return False                     # O(1) константаное
    return True                              # O(1) константаное

# Line #    Mem usage    Increment  Occurrences   Line Contents
# =============================================================
#     69     20.9 MiB     20.9 MiB           1   @profile
#     70                                         def check_3(lst_obj):
#     71                                         """Функция должная вернуть True, если все элементы списка различаются.
#     72
#     73                                             Алгоритм 3:
#     74
#     75
#     76
#     77
#     78
#     79     21.0 MiB      0.1 MiB           1       lst_copy = list(lst_obj)
#     80     21.0 MiB      0.0 MiB           1       lst_copy.sort()
#     81     21.0 MiB      0.0 MiB       10000       for i in range(len(lst_obj) - 1):
#     82     21.0 MiB      0.0 MiB        9999           if lst_copy[i] == lst_copy[i+1]:
#     83                                                     return False
#     84     21.0 MiB      0.0 MiB           1       return True


# for j in (50, 500, 1000, 5000, 10000):
#     # Из 100000 чисел возьмем 'j' случайно выбранных
#     # Всего 10 тыс. чисел
#     lst = sample(range(-100000, 100000), j)
# print("Проверка\nстарых\nзначений")
# print("(1) - 32.7 MiB,\n(2) - 32.5 MiB,\n(3) - 32.6 MiB  ")
# check_1(lst)
# check_2(lst)
# check_3(lst)


# Решение  =======================================================================================
# Как видно по замерам, основная проблема памяти тут заключаеться в цикле формирующем список значений.

print("Проверка\nновых\nзначений")
array = np.random.randint(-100000, 100000, 10000)
print("(1) - 31.9 MiB,\n(2) - 31.3 MiB ,\n(3) - 31.4 MiB MiB  ")
check_1(array)
check_2(array)
check_3(array)


# Как видим numpy уменьшил количество занемаймой памяти !!!
