from memory_profiler import memory_usage
from random import randint
import numpy as np
from pympler import asizeof
import array
"""
Задание 1.

Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python

На каждый скрипт нужно два решения - исходное и оптимизированное.

Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler

Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler

Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.


ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.

Это файл для четвертого скрипта
"""
def decor(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func()
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return res, mem_diff
    return wrapper


# lst = [i for i in range(1, 100000)]
# print(f'Создание простого списка : {asizeof.asizeof(lst)} Mib')
# to_lst = []
# print(f'Создание пустого простого списка :{asizeof.asizeof(to_lst)} Mib')

# неоптимизированная функция. Задание 5.3, алгоритмы
@decor
def lst_append():
    lst = [i for i in range(1, 100000)]
    to_lst = []
    for i in lst:
        to_lst.append(i)
    return to_lst

# lst_2 = np.array([i for i in range(1, 100000)])
# print(f'Создание numpy списка : {asizeof.asizeof(lst_2)}Mib')
# to_lst_2 = np.array([])
# print(f'Создание numpy пустого списка : {asizeof.asizeof(to_lst_2)} Mib')

# оптимизированная функция.
@decor
def lst_append_2():
    lst_2 = np.array([i for i in range(1, 100000)])
    to_lst_2 = np.array([])
    arr = np.append(lst_2, to_lst_2)
    lst_3 = arr.tolist()
    return lst_3

if __name__ == '__main__':
    res, mem_diff = lst_append()
    print(f"Выполнение  неоптимизированной функции заняло {mem_diff} Mib")

if __name__ == '__main__':
    res, mem_diff = lst_append_2()
    print(f"Выполнение оптимизированной функции заняло {mem_diff} Mib")

"""Использование Numpy позволяет значительно снизить количество потребляемой памяти,
особенно когда массив содержит большое количество элементов(примерно в 2 раза). """

