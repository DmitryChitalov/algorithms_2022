"""
Задание 2.

Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.

Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.

Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение.
"""
# ============= Итоги ==============
# def создает объект-функцию и присваивает его переменной.
# При декорировании фукнции через profile, значение данной переменной 
# переопределяется, и она начинает ссылаться на объект-пофилировщик,
# внутри которого и вызывается профилируемая функция.
# Если декорируемая функция рекурсивно вызывает себя 
# через переменную, которая ссылалась раньше не первоначальную функцию, 
# а теперь ссылается на объект-профилировщик, тогда при каждом 
# рекурсивном вызове, профилировщик выполняет свой 
# основной функционал - вывод информации.
# Что бы это исправить необходимо сделать внешнюю функцию-обертку, 
# которая будет вызываться только один раз, тем самым профилировщик 
# подсчитает суммарные цифры потребления памяти для данной функции-обертке. 
# Эти суммарные цифры равны сумме отдельных вызовов рекурсивной внутренней функции.

from memory_profiler import profile


@profile(precision=4)
def calc_odd_even(number):
    def calc_odd_even(number):
        if number < 10:
            return {'odd': 1, 'even': 0}

        number = number // 10
        odd_even = calc_odd_even(number)
        is_even_number_now = bool((odd_even['odd'] + odd_even['even']) % 2)
        if is_even_number_now:
            return {'odd': odd_even['odd'], 
                    'even': odd_even['even'] + 1}
        else:
            return {'odd': odd_even['odd'] + 1, 
                    'even': odd_even['even']}
    return calc_odd_even(number)

print(calc_odd_even(11))