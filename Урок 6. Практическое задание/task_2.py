"""
Задание 2.

Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.

Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.

Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""
from memory_profiler import profile, memory_usage
import random


def decor(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func(args[0])
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return mem_diff

    return wrapper


@decor
# @profile
def num_sum(n):
    if n == 1:
        return 1
    else:
        return num_sum(n - 1) + n


@decor
# @profile
def recur_sum(n):
    ''' Через тернарный оператор'''
    return n if n == 0 else n + recur_sum(n - 1)


"""
При попытке замерить профиль используемой памяти декоратором profile, функции для расчета суммы ряда натуральных чисел,
уже при длине ряда 8 элементов profile запускается 8 раз и выдаёт 8 таблиц с замерами профиля используемой памяти. Что
конечно очень неудобно особенно если порядки рядов будут очень высоки!!! Попробуем решить эту проблему
"""
# Попробуем использовать функцию memory_usage из модуля memory_profiler и напишем свой декоратор для замера
# используемой памяти. Размещён вначале программы.


if __name__ == '__main__':
    n = random.randint(1, 100)
    print(f'Вычислим сумму ряда для n = {n} и проверим равенство! ')
    # res = num_sum(n)
    # res_1 = recur_sum(n)
    # f_res = (n * (n + 1) / 2)
    # print(f'Получим результат: 1 + 2 + 3 +  ... + n = {res} , n(n+1)/2  = {f_res}')
    # print()
    # print(f'Получим результат: 1 + 2 + 3 +  ... + n = {res_1} , n(n+1)/2  = {f_res}')  # Через тернарный оператор
    #
    # if res == f_res and res_1 == f_res:
    #     print('Равенство верно!')
    # else:
    #     print('Равенство не верно!')

    mem_diff = num_sum(n)
    print(f"Выполнение функции num_sum заняло {mem_diff} Mib")
    mem_diff = recur_sum(n)
    print(f"Выполнение функции recur_sum заняло {mem_diff} Mib")

"""
Результат получился отличный, мы видим только количество памяти потребляемой функцией при работе. Это колличество
примерно одинаково, но при маленьких значениях числа элементов, меньше потребляет 1, а при больших 2. При числе 
элементов около 1000 вычисления потребляемой памяти становятся затруднительны из-за медленнной работы декоратора,
видимо это связанно с работой функции memory_usage.
Результат работы декоратора на двух функциях.

Вычислим сумму ряда для n = 85 и проверим равенство! 
Выполнение функции num_sum заняло 0.1953125 Mib
Выполнение функции recur_sum заняло 0.07421875 Mib
"""
