"""
Задание 2.

Попытайтесь выполнить профилирование памяти в любом скрипте с рекурсией.

Вам нужно обнаружить проблему в процессе этого. Но проблема связана не с тем,
что рекурсия потребляет много памяти, а с самим процессом замеров.

Опищите эту проблему и найдите простой путь ее решения.
Опишите этот путь и покажите его применение
"""
from memory_profiler import memory_usage, profile


@profile
def recursion_wrapper(func, *args):
    a = func(*args)
    return a


def even_odd(n):
    if n // 10 == 0:
        return 1 - n % 2, n % 2
    return 1 - n % 2 + even_odd(n // 10)[0], n % 2 + even_odd(n // 10)[1]


s = int(''.join((str(i * 3 % 10) for i in range(20))))
print(f"В числе  {s} количество четрых и нечетных цифр {recursion_wrapper(even_odd, s)}")
"""
Если профилировать рекурсивную функцию, то результат будет печататься после каждого завершенного вызова;
количество вызовов равно глубине рекурсии (пробовала, когда делала задание 1_5)
Иногда это даже полезно, но иногда - вообще нет.

Выход из ситуации - обернуть рекурсивную функцию оболочкой. И замерять оболочку.
Минус в том, что таким образом невозможно детально посмотреть работу рекурсивной функции: 
профайлер печатает одно измерение на ее выполнение.

А еще profile не отсекает использование памяти. Считает, что ее ноль. А если увеличить глубину рекурсии,
то катастрофически увеличивается время выполнения кода, и мне надоедает ждать.
В задании 1_5 я с этим намучалась - пока не поняла, что самостоятельно написанный memorizer берет.
"""
