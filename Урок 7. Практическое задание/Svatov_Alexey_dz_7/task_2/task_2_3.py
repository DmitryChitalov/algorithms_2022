"""
Задание 2. Массив размером 2m + 1, где m – натуральное число,
заполнен случайным образом. Найдите в массиве медиану.
Медианой называется элемент ряда, делящий его на
две равные по длине части:
в одной находятся элементы,
которые не меньше медианы,
в другой – не больше медианы.

Решите задачу тремя способами:

3) с помощью встроенной функции поиска медианы

сделайте замеры на массивах длиной 10, 100, 1000 элементов

В конце сделайте аналитику какой трех из способов оказался эффективнее
"""

from random import randint
from timeit import timeit
from numpy import median


def array_gen(m):
    return [randint(-100, 100) for _ in range(2 * m + 1)]


def median_numpy(lst):
    return f'Медиана списка = {int(median(lst))}'


test_list_11 = array_gen(5)
test_list_101 = array_gen(50)
test_list_1001 = array_gen(500)

print(timeit("median_numpy(test_list_11[:])", globals=globals(), number=1000))
print(timeit("median_numpy(test_list_101[:])", globals=globals(), number=1000))
print(timeit("median_numpy(test_list_1001[:])", globals=globals(), number=1000))

"""
0.015126975000384846
0.014403244998902665
0.05303201199967589
"""

"""
При малых размерах списков наиболее эффективным оказался способ с удалением максимальных значений, 
                                                         потом сортировка Шелла,
                                                         затем NumPy.

При размере в 101 элемент, NumPy уже показал результаты лучше, чем у двух других способов, но всё ещё сопоставимые.

При размере в 1001 элемент, NumPy показал результат на 2 порядка лучше, чем "конкуренты".

Таким образом, можно сделать вывод, что использование NumPy предпочтительнее, т.к. в реальных условиях редко бывают 
массивы малых размеров. 
Также NumPy показал наименьшую прогрессию по снижению эффективности, в зависимости от объёма списка.
Тогда как способ с удалением элементов и сортировка Шелла увеличивали время выполнения на один порядок 
при увеличении объёма массива также на порядок.
"""
