"""
Задание 1.

Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.

Обязательно сделайте замеры времени обеих реализаций и дайте ответ помогла ли
доработка и в каких случаях она будет эффективной.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.
"""

from random import randint
from timeit import timeit


def bubble_sort_to_min(lst_obj):
    n = 1
    while n < len(lst_obj):
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


def bubble_sort_to_min_opt(lst_obj):
    n = 1
    while n < len(lst_obj):
        count = 0  # Счетчик замен (движений "пузырька")
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
                count += 1  # Если произошла замена за проход - приращаем счетчик
        if count == 0:  # Если за проход небыло сделанно не одной замены - все отсортированно)
            return lst_obj
        n += 1
    return lst_obj


def start_1000(n=1000):
    for i in range(n):
        temp_list = [randint(-100, 100) for _ in range(1000)]
        bubble_sort_to_min(temp_list[:])


def start_1000_opt(n=1000):
    for i in range(n):
        temp_list = [randint(-100, 100) for _ in range(1000)]
        bubble_sort_to_min_opt(temp_list[:])


orig_list = [randint(-100, 100) for _ in range(30)]
print(orig_list)
print(bubble_sort_to_min(orig_list[:]))
print(bubble_sort_to_min_opt(orig_list[:]))

print("Замер 30 элементов:")
print(timeit("bubble_sort_to_min(orig_list[:])", globals=globals(), number=1000))
print(timeit("bubble_sort_to_min_opt(orig_list[:])", globals=globals(), number=1000))

orig_list = [randint(-100, 100) for _ in range(100)]

print("Замер 100 элементов:")
print(timeit("bubble_sort_to_min(orig_list[:])", globals=globals(), number=1000))
print(timeit("bubble_sort_to_min_opt(orig_list[:])", globals=globals(), number=1000))

orig_list = [randint(-100, 100) for _ in range(1000)]

print("Замер 1000 элементов:")
print(timeit("bubble_sort_to_min(orig_list[:])", globals=globals(), number=1000))
print(timeit("bubble_sort_to_min_opt(orig_list[:])", globals=globals(), number=1000))

print("Замер 1 функции с 1000 разных массивов:")
print(timeit("start_1000()", globals=globals(), number=1))
print(timeit("start_1000_opt()", globals=globals(), number=1))
"""
Сортировака пузырьком по убыванию получилась - функция bubble_sort_to_min, так же получилась и улучшенная функция:
bubble_sort_to_min_opt
Результаты замеров:
[-89, 74, -3, -56, 90, 15, 60, 94, -30, -23, -15, 82, -36, 7, 59, -94, 35, -65, -14, 77, -48, -63, -19, -6, -4, -11, -94, 62, 31, -5]
[94, 90, 82, 77, 74, 62, 60, 59, 35, 31, 15, 7, -3, -4, -5, -6, -11, -14, -15, -19, -23, -30, -36, -48, -56, -63, -65, -89, -94, -94]
[94, 90, 82, 77, 74, 62, 60, 59, 35, 31, 15, 7, -3, -4, -5, -6, -11, -14, -15, -19, -23, -30, -36, -48, -56, -63, -65, -89, -94, -94]
0.06162300001597032
0.09290940000209957
0.46573669998906553
0.6890602000057697
47.84829019999597
77.54718319998938
Для массива из 30 элементов выводил на печать оригинальный массив, и результат работы обеих функций, что бы убедиться в
их работоспособности.
На первый взгляд, все в пустую, хотя в теории - должен быть хоть какой то выйгрыш!
и тут я поменял тактику - меряем 1000 запусков функции и в каждом запуске генерируем новый массив случайных чисел!
Потому как одни и те же данные смысла мерить нет!
[-19, 16, -27, -83, -54, -70, 35, -96, -35, -98, 57, -35, -19, 68, 64, -13, 58, -50, 47, 60, 44, -74, 55, 49, 91, 95, 61, -11, 62, -17]
[95, 91, 68, 64, 62, 61, 60, 58, 57, 55, 49, 47, 44, 35, 16, -11, -13, -17, -19, -19, -27, -35, -35, -50, -54, -70, -74, -83, -96, -98]
[95, 91, 68, 64, 62, 61, 60, 58, 57, 55, 49, 47, 44, 35, 16, -11, -13, -17, -19, -19, -27, -35, -35, -50, -54, -70, -74, -83, -96, -98]
Замер 30 элементов:
0.06062429997837171
0.05463759999838658
Замер 100 элементов:
0.47658610000507906
0.505667799996445
Замер 1000 элементов:
53.209794099995634
63.744993300002534
Замер 1 функции с 1000 разных массивов:
58.11642010000651
57.055868600000395
Наши теоритические данные подтвердились - мы действительно смогли ускорить "пузырек" относительно оригинала!
Вот только выйгрыш настолько незначительный, что теряеться всякий смысл, да и среднеквадратичная сложность никуда не 
уходит.
"""
