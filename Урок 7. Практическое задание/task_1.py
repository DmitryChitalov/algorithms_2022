"""
Задание 1.

Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.

Обязательно сделайте замеры времени обеих реализаций и дайте ответ помогла ли
доработка и в каких случаях она будет эффективной.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.
"""
from random import randint
from timeit import timeit


def bubble_sort(our_list):
    # Проходим по всем элементам.
    for i in range(len(our_list)):
        # Если текущий больше следующего, меняем их местами.
        for j in range(len(our_list) - 1):
            if our_list[j] < our_list[j+1]:
                # Замена
                our_list[j], our_list[j+1] = our_list[j+1], our_list[j]
    return our_list


def bubble_sort2(our_list):
    is_sorted = True # Флаг по умолчанию установлен как True
    for i in range(len(our_list)):
        """
        Если текущий больше следующего, меняем их местами.
        При этом, в конец списка будут попадать минимальные элементы,
        поэтому на следующую итерацию внешнего цикла, диапазон прохода во внутреннем уменшается на минус 1.

        К примеру, на второй итерации можно не проверять самый последний элемент, 
        т.к. на первой итерации туда переместился минимальный элемент. Он меньше всех остальных.
        """
        for j in range(len(our_list) - i - 1):
            if our_list[j] < our_list[j+1]:
                our_list[j], our_list[j+1] = our_list[j+1], our_list[j]
                is_sorted = False
        if is_sorted: # Если ни разу не было перестановок, можнно считать, что список отсортирован и просто вернуть его.
            return our_list 
    return our_list


lst = [randint(0, 100) for _ in range(0, 20)]
print(f'Проверка правильности выполнения: \n'
      f'Неоптимизированный: '
      f'{bubble_sort(lst)} \n'
      f'Оптимизированный: '
      f'{bubble_sort(lst)}'
      )


# Замеры времени
lst = [randint(0, 100) for _ in range(0, 200)]
n = 1000

print(
    f'Неоптимизированный алгоритм. Случайно сгенерированный список: ',
    timeit(
        'bubble_sort(lst[:])',
        globals=globals(),
        number=n
    )
)

print(
    f'Оптимизированный алгоритм. Случайно сгенерированный список: ',
    timeit(
        'bubble_sort2(lst[:])',
        globals=globals(),
        number=n
    )
)

lst = list(range(0, 100))[::-1]

print(
    f'Неоптимизированный алгоритм. Заведомо отсортированный список: ',
    timeit(
        'bubble_sort(lst[:])',
        globals=globals(),
        number=n
    )
)

print(
    f'Оптимизированный алгоритм. Заведомо отсортированный список: ',
    timeit(
        'bubble_sort2(lst[:])',
        globals=globals(),
        number=n
    )
)

"""
Выводы:

Оптимизарованный алгоримт быстрее на случайно сгенерированном списке
потому, что у него меньше итераций на вложенном цикле.

Оптимизарованный алгоримт быстрее на заведомо отсортированном списке
потому, что он проверяет один раз весь список и если не было перестановок, больше проверек
не делается и просто возвращается список.

"""

