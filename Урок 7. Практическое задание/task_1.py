"""
Задание 1.

Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.

Обязательно сделайте замеры времени обеих реализаций и дайте ответ помогла ли
доработка и в каких случаях она будет эффективной.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.
"""
from random import randint
from timeit import timeit


def reverse_bubble(arr):
    """Сортировка пузырьком"""
    i = 1
    while i < len(arr):
        for j in range(len(arr) - i):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        i += 1
    return arr


def reverse_bubble_flag(arr):
    """
    Сортировка пузырьком 'с флагом'
    после каждого прохода по массиву,
    проверяется были произведены перестановки или нет
    """
    i = 1
    something_changed = True
    while i < len(arr) and something_changed:
        something_changed = False
        for j in range(len(arr) - i):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                something_changed = True
        i += 1
    return arr


if __name__ == '__main__':
    array_1000 = [randint(-100, 100) for _ in range(1000)]
    array_100 = array_1000[:100]
    array_10 = array_1000[:10]
    array_1000_sorted = [i for i in range(1000, 0, -1)]

    print('Исходный массив:', array_10)
    print('Отсортированный массив:', reverse_bubble(array_10[:]))
    print('-' * 70)

    print('Сортировка пузырьком, массив из 10 элементов:',
          timeit('reverse_bubble(array_10[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком, массив из 100 элементов:',
          timeit('reverse_bubble(array_100[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком, массив из 1000 элементов:',
          timeit('reverse_bubble(array_1000[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком, отсортированный массив из 1000 элементов:',
          timeit('reverse_bubble(array_1000_sorted[:])', globals=globals(), number=1000))
    print('-' * 70)

    print('Сортировка пузырьком с флагом, массив из 10 элементов:',
          timeit('reverse_bubble_flag(array_10[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком с флагом, массив из 100 элементов:',
          timeit('reverse_bubble_flag(array_100[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком с флагом, массив из 1000 элементов:',
          timeit('reverse_bubble_flag(array_1000[:])', globals=globals(), number=1000))
    print('Сортировка пузырьком с флагом, отсортированный массив из 1000 элементов:',
          timeit('reverse_bubble_flag(array_1000_sorted[:])', globals=globals(), number=1000))
    print('-' * 70)

# Исходный массив: [87, 56, -2, -36, 82, -31, -28, -33, -62, 32]
# Отсортированный массив: [87, 82, 56, 32, -2, -28, -31, -33, -36, -62]
# ----------------------------------------------------------------------
# Сортировка пузырьком, массив из 10 элементов: 0.008401300001423806
# Сортировка пузырьком, массив из 100 элементов: 0.7080562000046484
# Сортировка пузырьком, массив из 1000 элементов: 74.24870080000255
# Сортировка пузырьком, отсортированный массив из 1000 элементов: 32.53480410002521
# ----------------------------------------------------------------------
# Сортировка пузырьком с флагом, массив из 10 элементов: 0.007582199992612004
# Сортировка пузырьком с флагом, массив из 100 элементов: 0.7082411000155844
# Сортировка пузырьком с флагом, массив из 1000 элементов: 77.69574109997484
# Сортировка пузырьком с флагом, отсортированный массив из 1000 элементов: 0.06986960000358522
# ----------------------------------------------------------------------
# Вывод:
# добавление "флага" в сортировку работает только на отсортированных массивах.
# в случайном массиве работают одинаково,
# а на очень больших массивах дополнительная проверка в цикле даже замедляет работу
