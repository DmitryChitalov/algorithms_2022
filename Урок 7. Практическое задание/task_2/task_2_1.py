"""
Задание 2. Массив размером 2m + 1, где m – натуральное число,
заполнен случайным образом. Найдите в массиве медиану.

Медианой называется элемент ряда, делящий его на
две равные по длине части:
в одной находятся элементы,
которые не меньше медианы,
в другой – не больше медианы.

Решите задачу тремя способами:

1) с помощью сортировки, которую мы не рассматривали на уроке (Гномья, Шелла,
Кучей)

сделайте замеры на массивах длиной 10, 100, 1000 элементов
"""
from random import randint
from timeit import timeit


def heapsort(data: list):
    """Сортировка методом кучи (heapsort). Функция формирует сортирующее дерево, перебирая элементы справа-налево
    Создавая ветки элементов, ветка создается между первым элементом i[0] и элементом,
    который стоит перед элементом больше первого i[i>i[0]-1]"""
    for start in range((int(len(data) - 2) // 2), -1, -1):
        heapsift(data, start, len(data) - 1)

    # Первый элемент массива всегда соответствует корню сортирующего дерева
    # и поэтому является максимумом для неотсортированной части массива.
    for end in range(len(data) - 1, 0, -1):
        # Меняем этот максимум местами с последним
        # элементом неотсортированной части массива
        data[end], data[0] = data[0], data[end]
        # После обмена в корне сортирующего дерева немаксимальный элемент
        # Восстанавливаем сортирующее дерево
        # Ветку для неотсортированной части массива
        heapsift(data, 0, end - 1)
    return data


# Ветка сверху вниз, в результате которой восстанавливается сортирующее дерево
def heapsift(data: list, start: int, end: int):
    # Начало подмассива - узел, с которого начинаем просейку вниз
    root = start
    # Цикл просейки продолжается до тех пор,
    # пока встречаются потомки, большие чем их родитель
    while True:
        child = root * 2 + 1  # Левый потомок
        # Левый потомок за пределами подмассива - завершаем просейку
        if child > end:
            break
        # Если правый потомок тоже в пределах подмассива,
        # то среди обоих потомков выбираем наибольший
        if child + 1 <= end and data[child] < data[child + 1]:
            child += 1
        # Если больший потомок больше корня, то меняем местами
        # при этом больший потомок сам становится корнем,
        # от которого дальше опускаемся вниз по дереву
        if data[root] < data[child]:
            data[root], data[child] = data[child], data[root]
            root = child
        else:
            break


def finding_mediana(list_m: list, middle: int):
    """В сущности функция оболочка, чей задачей является вызвать heapsort и вытащить их результата его работы медиану"""
    return heapsort(list_m[:])[middle]


m = 10
orig_list = [randint(-100, 100) for _ in range(2*m+1)]
print(f'Исходный список: {orig_list}')
print(f'Результат сортировки копии списка: {heapsort(orig_list[:])}')
print(f'Медиана = {finding_mediana(orig_list[:], m)}')

# замеры 10
print(
    timeit(
        "finding_mediana(orig_list[:], m)",
        globals=globals(),
        number=1000))

orig_list = [randint(-100, 100) for _ in range(100)]

m = 100
orig_list = [randint(-100, 100) for _ in range(2*m+1)]
# замеры 100
print(
    timeit(
        "finding_mediana(orig_list[:], m)",
        globals=globals(),
        number=1000))

m = 1000
orig_list = [randint(-100, 100) for _ in range(2*m+1)]

# замеры 1000
print(
    timeit(
        "finding_mediana(orig_list[:], m)",
        globals=globals(),
        number=1000))
