"""
Задание 2. Массив размером 2m + 1, где m – натуральное число,
заполнен случайным образом. Найдите в массиве медиану.

Медианой называется элемент ряда, делящий его на
две равные по длине части:
в одной находятся элементы,
которые не меньше медианы,
в другой – не больше медианы.

Решите задачу тремя способами:

2) без сортировки

сделайте замеры на массивах длиной 10, 100, 1000 элементов
"""
from random import randint
from timeit import timeit


def find_m_2(size, n=1000):
    """
    Считаю, чтто неинтересно и не совсем наглядно замерять один и тот же массив 1000 раз, по этому в данной функции
    на каждое новое измерение будет генерироваться новый массив, а возвращать функция будет список из медиан, найденных
    для каждого измерения
    В этой функции не пользуемся сортировкой.
    :param size: Размер списка
    :param n: Длинна элементов массива, в котором ведеться поиск (учитывая формулу из задания 2m + 1 и то, что
    на сортировку отправляем массивы 10, 100, 1000 элементов, увиличиваем этот параметр на 1 в функции)
    :return: список найденных медиан.
    """
    median_list = []
    for i in range(n):
        temp_list = [randint(-100, 100) for _ in range(size + 1)]
        for j in range(int(size / 2)):
            del_elem = max(temp_list[:])
            temp_list.remove(del_elem)
        median_list.append(max(temp_list))
    return median_list


print("Замер 10 элементов:")
print(timeit("find_m_2(10)", globals=globals(), number=1))
print("Замер 100 элементов:")
print(timeit("find_m_2(100)", globals=globals(), number=1))
print("Замер 1000 элементов:")
print(timeit("find_m_2(1000)", globals=globals(), number=1))

"""
Результаты измерений:
Замер 10 элементов:
0.00851619997411035
Замер 100 элементов:
0.134862399980193
Замер 1000 элементов:
5.59788300000946
Данные получились весьма интересными, скорость данного варианта решения впечатляет. 
Мне кажеться, все дело в сложности: если для массива в n элементов в теле цикла помски медианы сложность будет O(n)
То сложность самого цикла при такой реализации всегда будет O(n/2 -1)
И итоговая сложность будет O(n^2 / 2) . Т.е. функция по сложности все равно остаеться квадратичной, но мы всегда будем 
перебирать только половину списка, отсюда и выйгрыш в скорости. 
"""