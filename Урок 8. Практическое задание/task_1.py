"""
Задание 1.

Реализуйте кодирование строки по алгоритму Хаффмана.
У вас два пути:
1) тема идет тяжело? тогда вы можете,
опираясь на примеры с урока, сделать свою версию алгоритма
Разрешается и приветствуется изменение имен переменных,
выбор других коллекций, различные изменения
и оптимизации.

2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например,
через ООП или предложить иной подход к решению.
"""
import heapq  # очередь с приоритетами
from collections import Counter, namedtuple


# внутренний узел нашего дерева
# конструктор namedtuple принимает первым аргументом имя класса, который
# мы хотим объявить, а вторым аргументом его атрибуты.
#
# внутренний узел нашего дерева, left - левый потомок, right - правый потомок
class Node(namedtuple("Node", ["left", "right"])):
    def walk(self, code, acc):
        # второй аргумент - это префикс кода, который мы накопили, спускаясь
        # от корня до данного узла или до листа
        self.left.walk(code, acc + "0")
        self.right.walk(code, acc + "1")


# лист нашего дерева, char - символ, который в этом листе записан
class Leaf(namedtuple("Leaf", ["char"])):
    def walk(self, code, acc):
        code[self.char] = acc or "0"


def huffman_encode(s):
    # очередь будет представлена в виде списка из пар, где первый элемент -
    # это частота символа, а второй - лист
    h = []
    for ch, freq in Counter(s).items():
        # второй компонент - это счётчик, который должен быть уникален для
        # всех листьев
        h.append((freq, len(h), Leaf(ch)))  # частота, счётчик, лист
        # теперь можем гарантировать, что для всех листов в списке h второй
        # компонент различен, потому что после каждого шага длина h
        # увеличивается на единицу.

    # построим очередь с приоритетами
    heapq.heapify(h)

    # При добавлении внутренних узлов тоже введём уникальный счётчик
    count = len(h)  # инициализируем его размером нашей очереди с приоритетами
    # а затем будем инкрементировать на каждом шаге.

    # Теперь можем с ней работать
    # До тех пор, пока в очереди есть хотя бы два элемента
    while len(h) > 1:
        freq1, _count1, left = heapq.heappop(h)  # достаём элемент с
        # минимальной частотой
        freq2, _count2, right = heapq.heappop(h)    # и следующий за ним элемент
        # с минимальной частотой

        # а затем добавляем в очередь новый элемент, частота которого
        # равняется сумме частот вытащенных элементов, а второй - это
        # новый внутренний узел, у которого потомки left и right
        # соответственно.

        heapq.heappush(h, (freq1 + freq2, count, Node(left, right)))
        count += 1

    # после выхода из цикла while в очереди с приоритетами будет
    # один элемент, приоритет которого нам не важен, а сам элемент -
    # это корень построенного дерева.

    # чтобы получить кодирование Хаффмана, нужно дерево обойти, начиная с
    # корня, и заполнить словарь 'code', который мы объявили
    # если строка пустая, то очередь тоже пустая!
    code = {}
    if h:
        [(_freq, _count, root)] = h
        root.walk(code, "")
    return code


def huffman_decode(en, code):
    pointer = 0
    encoded_str = ''
    while pointer < len(en):
        for ch in code.keys():
            if en.startswith(code[ch], pointer):
                encoded_str += ch
                pointer += len(code[ch])
    return encoded_str


def main():
    s = input()
    code = huffman_encode(s)
    encoded = "".join(code[ch] for ch in s)
    print(len(code), len(encoded))  # len(code) - количество ключей в словаре
    # len(encoded) - длина закодированной строки
    for ch in sorted(code):  # выводим сам код (для удобства
        # в алфавитном порядке)
        print("{}: {}".format(ch, code[ch]))  # описываем, как кодируется
        # каждый символ
    print(encoded)  # вывод закодированной строки, т.е. encoded

    s_decode = huffman_decode(encoded, code)  # раскодированная строка
    assert s_decode == s
    print(s_decode)


if __name__ == "__main__":
    main()
