"""
Задание 1.

Реализуйте кодирование строки по алгоритму Хаффмана.
У вас два пути:
1) тема идет тяжело? тогда вы можете,
опираясь на примеры с урока, сделать свою версию алгоритма
Разрешается и приветствуется изменение имен переменных,
выбор других коллекций, различные изменения
и оптимизации.

2) тема понятна? постарайтесь сделать свою реализацию.
Вы можете реализовать задачу, например,
через ООП или предложить иной подход к решению.
"""

from collections import Counter, deque


def haffman_tree(string):
    # Считаем уникальные символы.
    # Counter({'s': 1, 't': 1, 'r': 1, 'i': 1, 'n': 1, 'g': 1})
    count = Counter(string)
    # Сортируем по возрастанию количества повторений.
    # deque([('s', 1), ('t', 1), ('r', 1), ('i', 1), ('n', 1), ('g', 1)])
    el_sort = deque(sorted(count.items(), key=lambda item: item[1]))
    # Проверка, если строка состоит из одного повторяющего символа.
    if len(el_sort) != 1:
        # Цикл для построения дерева
        while len(el_sort) > 1:
            # далее цикл объединяет два крайних левых элемента
            # Вес объединенного элемента (накопленная частота)
            weight = el_sort[0][1] + el_sort[1][1]
            # Словарь из 2 крайних левых элементов, попутно вырезаем их
            # из "el_sort" (из очереди).
            # dictionary - объединенный элемент
            dictionary = {0: el_sort.popleft()[0],
                          1: el_sort.popleft()[0]}

            # Ищем место для ставки объединенного элемента
            for i, _count in enumerate(el_sort):
                if weight > _count[1]:
                    continue
                else:
                    # Вставляем объединенный элемент
                    el_sort.insert(i, (dictionary, weight))
                    break
            else:
                # Добавляем объединенный корневой элемент после
                # завершения работы цикла

                el_sort.append((dictionary, weight))
    else:
        # приравниваем значение 0 к одному повторяющемуся символу
        weight = el_sort[0][1]
        dictionary = {0: el_sort.popleft()[0], 1: None}
        el_sort.append((dictionary, weight))
    # {0: {0: 's', 1: 't'}, 1: {0: {0: 'n', 1: 'g'}, 1: {0: 'r', 1: 'i'}}}
    # словарь - дерево
    return el_sort[0][0]


code_table = dict()

"""
tree - {
0: {0: 's', 1: 't'},
1: {0: {0: 'n', 1: 'g'}, 1: {0: 'r', 1: 'i'}}
}
"""


def haffman_code(tree, path=''):
    # Если элемент не словарь, значит мы достигли самого символа
    # и заносим его, а так же его код в словарь (кодовую таблицу).
    if not isinstance(tree, dict):
        code_table[tree] = path
    # Если элемент словарь, рекурсивно спускаемся вниз
    # по первому и второму значению (левая и правая ветви).
    else:
        haffman_code(tree[0], path=f'{path}0')
        haffman_code(tree[1], path=f'{path}1')


# строка для кодирования
string_ = "string"

# функция заполняет кодовую таблицу (символ-его код)
# {'s': '00', 't': '01', 'r': '110', 'i': '111', 'n': '100', 'g': '101'}
haffman_code(haffman_tree(string_))

# code_table - {'s': '00', 't': '01', 'r': '110', 'i': '111', 'n': '100', 'g': '101'}

# выводим коды для каждого символа
for i in string_:
    print(code_table[i], end=' ')


'''
Разбирал пример с урока, на примере своей строки.
В режиме дебага полазил по коду.
Тема, конечно тяжеловата, легко запутаться.
'''